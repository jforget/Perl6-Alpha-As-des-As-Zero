-*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf-8

=head1 Introduction

Voici la présentation que j'ai donnée aux Journées Perl 2018, le 18 mai 2018.
J'y ajoute certaines réflexions que l'assistance m'a faites lors de l'exposé.

Je cherchais un projet utilisant Perl 6 et MongoDB et qui puisse intéresser l'auditoire
des Journées Perl. J'ai donc exhumé des tréfonds
de ma mémoire une idée consistant à écrire un programme jouant à
l'L<As des As|https://boardgamegeek.com/boardgame/798/ace-aces-handy-rotary-series>. 
Ce n'est que plus tard que j'ai constaté que ce projet pouvait bénéficier de
l'utilisation de Bailador (la version Perl 6 de Dancer2) et que cela me permettait
de célébrer le centenaire de la création de la RAF (1er avril 1918) et de la mort
de Manfred von Richthofen (21 avril 1918) ou, plus approximativement, la disparition 
de Georges Guynemer (11 septembre 1917) et l'armistice (11 novembre 1918).

=head2 Rappel

L'an dernier, j'ai présenté un système de reconnaissance
de caractères basé sur une interface entre un humain (fournissant
le moteur de reconnaissance de caractères) et une
machine (pour la base de données). J'aurais pu le présenter autrement.

=for html
<img src='comparaison-l-1.png' alt='Comparaison entre une cellule l (Lima) et un glyphe 1 (unité)' />

I<Copie d'écran personnelle. Les conditions de licence sont les mêmes que pour le texte.>

-- Maître, cette cellule contient un chiffre « 1 ».

-- Petit Scarabée, c'est la lettre « l ».

-- Ah, maître, je comprends la nature du « l ».

Présenté comme cela, vous avez reconnu, c'est du I<machine learning>
ou plus précisément du I<supervised machine learning>
(et ça fera bien dans mon CV).

=head2 Cette année

Récemment, nous avons appris que Google avait fait du I<supervised machine learning>
avec Google Alpha Go. Puis nous avons appris qu'ils avaient fait
une autre expérience sur le jeu de Go,
Google Alpha Go Zero, basé sur un mécanisme d'auto-apprentissage, ainsi
que l'équivalent pour les échecs, Google Alpha Chess Zero.
Le système ne connaît que les règles du jeu et le fait qu'une position
finale est gagnante ou perdante. Le système joue un grand nombre de
parties contre lui-même, analyse les résultats et en déduit les positions
et coups avantageux et les positions et coups foireux.

Cette idée ne date pas de 2017 ou 2018, je l'ai déjà rencontrée dans
les années 1970 avec un article décrivant une machine jouant au tic-tac-toe. Et depuis longtemps j'avais moi-même un projet
de « machine self-learning », que je vous présente ci-dessous. Et c'était le moment rêvé
de réaliser ce projet cette année, car 2018 c'est le centenaire de la création
de la RAF, de la mort au combat de Manfred von Richthofen et de l'armistice.

=head2 Digression sur les précurseurs des liens hypertextes

Quand a-t-on commencé à numéroter les pages des livres (ou des rouleaux de papyrus) ?
Quand a-t-on écrit pour la première fois "cf. page n" ?
Quand a-t-on pensé à ajouter un index des mots importants en fin d'ouvrage ?
Quand a-t-on écrit un ouvrage qui utilise de façon I<intensive> les renvois
à une autre page ?

À la suite des travaux des naturalistes du XVIIIe siècle (Jussieu, Buffon, Cuvier, etc)
on a commencé à publier des flores, des livres décrivant l'ensemble des végétaux
d'une région ou d'un biotope. Mon père m'en a montré une datant des années 1950
et qui était organisée sous la forme d'une série de questions-réponses :

=for html
<blockquote>

Comment sont les nervures des feuilles ? Si elles sont parallèles, voyez page 17.
Si elles forment un réseau arborescent avec une nervure centrale, des nervures primaires
se détachant de la nervure centrale, des nervures secondaires se détachant d'une nervure
primaire et ainsi de suite, voyez page 33.

=for html
</blockquote>

Page 17 et page 33 vous aviez d'autres questions, d'autres réponses et d'autres renvois.

Années 1960 (je crois) : on m'a raconté qu'à cette époque IBM avait composé des
manuels de dépannage sur le même principe :

=for html
<blockquote>
Si de la fumée sort de l'unité de disque, voyez page 17.
Si cela fait « crrr crrr crrr » voyez page 33.

=for html
</blockquote>

(Le texte est évidemment apocryphe, mais le principe est conservé.)

Dans les années 1970, j'ai vu à la télévision le sketch d'un duo d'humoristes
sur « le dictionnaire le plus petit du monde ». Ce qui prend de la place dans un dictionnaire
ce sont les définitions. Le personnage de l'un des humoristes avait pu
imprimer un dictionnaire au format de poche juste en éliminant les définitions.
Il expliquait à son interlocuteur avec un exemple ressemblant S<à :>

  Clown : voir Cirque.
  Cirque : voir Cercle.
  Cercle : voir Club
  Club : voir Assemblée
  Assemblée : voir Parlement.
  Parlement : voir Député.
  Député : voir Politicien.
  Politicien : voir Clown.

=head3 Les Livres dont vous êtes le héros, Le Sorcier de la Montagne de Feu

En 1982, est paru un livre d'un genre nouveau,
L<Warlock of the Firetop Mountain|http://fightingfantasy.wikia.com/wiki/The_Warlock_of_Firetop_Mountain_(book)>, 
bientôt traduit en français par
L<Gallimard Folio Junior|http://planete-ldvelh.com/page/dossier-edition-gallimard.html> 
sous le titre
« le Sorcier de la Montagne de Feu », le premier de la série
L<« les Livres dont vous êtes le héros »|http://www.gallimard-jeunesse.fr/Catalogue/GALLIMARD-JEUNESSE/Un-Livre-dont-vous-etes-le-Heros>.

=for html
<blockquote>

Paragraphe 1. Vous entrez dans une auberge. Au fond de la salle, vous voyez l'aubergiste à
son comptoir en train d'essuyer des verres. À gauche, dans un
recoin sombre, un homme seul à une table, la tête masquée par un
capuchon noir. Sur la droite, une demi-douzaine de nains des
montagnes boivent de la bière en rigolant bruyamment. Que faites-vous ?
Vous vous adressez à l'aubergiste, allez au paragraphe 17. Vous
vous asseyez à côté de l'homme encapuchonné, allez au paragraphe 33.
Vous vous adressez aux nains en leur disant S<« Salut> les ornements de 
S<jardin ! »> allez au paragraphe 52. 

=for html
</blockquote>

J'en ai eu cinq, dont deux édités par Gallimard et trois par Solar, il m'en reste quatre.

=for HTML
<img src='Les_livres_dont_vous_etes_le_heros.jpg' alt="Quatres livres dont vous êtes le héros" width='85%' />

I<Photo personnelle. Les conditions de licence sont les mêmes que pour le texte.>

=head1 L'As des AS, le Jeu

En 1981, un dénommé Alfred Leonardi a déposé un brevet pour un
nouveau type de jeu, mis au point avec Douglas Kaufman. Au lieu de réunir les deux joueurs sur une même
carte où ils poussent des pions, chaque joueur est muni d'un livret.

=for HTML
<img src='pic1051809-l.jpg' alt="Exemple de partie" width='85%' />

I<Photo prise par Chris Norwood et publiée sur L<Boardgame Geek|https://boardgamegeek.com/image/1051809/ace-aces-handy-rotary-series?size=large>. 
Licence L<Creative Commons Attribution 3.0 Unported, CC BY 3.0|https://creativecommons.org/licenses/by/3.0/>.>

=head2 Aperçu des règles

Le brevet donne un exemple de tour de jeu. Les deux joueurs commencent le tour page 1. Dans
les deux livrets, cette page montre que les deux avions ont le même cap et
que le DR1 est dans les 4 heures du Camel, c'est-à-dire que le Camel est dans
les 10 heures du DR1.

=for HTML
<img src='Page-1-GB-All.png' alt="Page 1 dans les deux livrets" width='100%' />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

En bas de la page, vous pouvez remarquer une série de flèches et une
série de nombres, des numéros de page. Chaque joueur choisit une flèche et
annonce le numéro de page correspondant à son adversaire. Par exemple, le joueur
allemand choisit la flèche la plus à gauche dans la page et annonce :

-- Je t'envoie en page 8.

Simultanément, le Britannique choisit la manœuvre en dessous de S<« EF »>
S<« Cruising> S<Left »> et répond :

-- Et toi, tu vas page 48.

=for HTML
<img src='Manoeuvre-1-8-48.png' alt="Page 1, flèche pointant vers la page 8 et flèche pointant vers la page 48" />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Le joueur allemand ouvre son livret page 48 et applique la même manœuvre que
précédemment, ce qui donne la page 96. De même, le joueur britannique ouvre
son livret page 8, repère la manœuvre choisie et obtient le même numéro de page, 96.

=for HTML
<img src='Pages-48-8.png' alt="Livret allemand page 48 et livret britannique page 8" />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

La page finale du tour est donc la page 96. Et comme vous pouvez le voir,
non seulement l'As des As est un précurseur des liens hypertextes, mais
c'est aussi un précurseur des jeux de tir en vision subjective
(I<First Person Shooters> en anglais), une douzaine d'années avant Wolfenstein 3D et Doom.

=for HTML
<img src='Page-96-All-GB.png' alt="Livret allemand page 96 et livret britannique page 96" />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Quant au mécanisme des tirs, c'est très simple. Vous commencez avec 12 points de vie. 
Chaque fois que vous aboutissez sur une page finale où vous recevez des pruneaux de l'avion
ennemi, vous perdez 1, 2 ou 4 points de vie, selon la page finale. On ne tient pas
compte des pages intermédiaires. Quand votre total de points de vie
est négatif ou nul, votre avion est abattu.

=head2 Dissection du mécanisme

Avec ce mécanisme, les pages finales sont toujours identiques. Cela émerveille les joueurs
qui découvrent le jeu, mais cela peut s'expliquer simplement. Oublions les cieux au-dessus
de L<Poelcapelle|http://acepilots.com/wwi/fr_guynemer.html> 
et de L<Vaux-sur-Somme|http://military.wikia.com/wiki/Manfred_von_Richthofen>,
et imaginons un parking de supermarché. Toutes
les voitures sont garées à proximité du bâtiment et il y a donc un large espace libre un
peu plus loin. Dans cet espace libre, se trouvent une Mini Austin et une VW Coccinelle
disposées ainsi (prenez les images en trait plein) :

=for html
<img src='Exp-1-A.png' alt='Position de départ des deux voitures' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Cela correspond à la page 1 des deux livrets.

Maintenant, imaginons que la VW fasse ce mouvement pendant que la Mini reste immobile.

=for html
<img src='Exp-1-B.png' alt="Mini dans sa position de départ et VW dans sa position d'arrivée" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

On obtient alors la disposition de la page 8. À ce moment-là, la Coccinelle s'arrête
et l'Austin démarre en faisant ce mouvement

=for html
<img src='Exp-1-C.png' alt="Position d'arrivée des deux voitures" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Le résultat est celui de la page 96.

=for html
<img src='Exp-1-D.png' alt="Position d'arrivée des deux voitures" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Deuxième étape de l'expérience. Les deux voitures se remettent dans la disposition correspondant à la page 1.

=for html
<img src='Exp-2-A.png' alt='Position de départ des deux voitures' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Puis c'est la Mini qui bouge la première pendant que la VW reste immobile.
On aboutit alors à la disposition de la page 48.

=for html
<img src='Exp-2-B.png' alt="VW dans sa position de départ et Mini dans sa position d'arrivée" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Et lorsque la Coccinelle effectue son mouvement, on aboutit à la configuration de la page 96.

=for html
<img src='Exp-2-C.png' alt="Position d'arrivée des deux voitures" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Troisième étape. Les voitures se remettent dans la position de la page 1, puis elles effectuent
I<simultanément> leur mouvement. Comme les deux fois précédentes, on obtient la disposition de
la page 96.

=for html
<img src='Exp-3-B.png' alt="Position d'arrivée des deux voitures" />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Ainsi donc, il est équivalent de faire les mouvements simultanément ou de les faire séquentiellement
dans un ordre ou dans l'autre. Et ce, aussi bien sur un parking de supermarché que dans
l'espace aérien de la Picardie ou des Flandres.

=head3 Cas particulier, la page 223.

Si vous consultez certains fichiers d'aide fournis par 
L<Boardgame Geek|https://www.boardgamegeek.com/boardgame/798/ace-aces-handy-rotary-series/files>,
vous verrez que le jeu de base sur une grille de 37 hexagones, permettant de 
générer 222 pages, représentant toutes les positions relatives des deux avions
du moment qu'ils sont à une distance inférieure ou égale à trois hexagones.
Et que se passe-t-il si la distance est S<supérieure ?>
Si, du fait de leurs manœuvres, les avions se retrouvent plus loin que cette
distance limite, le livret affiche une page spéciale, la
L<page 223|https://www.boardgamegeek.com/image/157327/ace-aces-handy-rotary-series>
qui représente des
nuages derrière lesquels l'ennemi a disparu. Même si cette page montre le ciel en avant de l'avion,
il est possible que l'ennemi ait disparu sur un côté ou derrière.

Si un seul joueur a une page intermédiaire à 223, on utilise la page intermédiaire de l'autre
pour obtenir la page finale. Impossible dans ce cas de faire la vérification présentée, expliquée et démythifiée
au paragraphe précédent. Un tel cas de figure se produit par exemple lorsque les deux avions se poursuivent
à grande distance. Supposons que nous soyons page 180, où le Camel est à longue distance
dans les onze heures du DR.1 et supposons que les deux avions avancent tout droit à vitesse
moyenne. Si l'on applique d'abord le mouvement du Camel, le DR.1 le perd de vue temporairement et la page
intermédiaire est la page 223, sur laquelle aucune manœuvre n'est indiquée. En revanche, si
l'on applique d'abord la manœuvre du DR.1, la page intermédiaire est la page 60 où 
le Camel est à distance moyenne dans les 10 heures du DR.1. Puis on applique le mouvement
du Camel, ce qui donne la page 180. Il n'est plus possible de vérifier que la page
finale est la même selon les deux déterminations, mais tant pis.

D'un autre côté, si les deux pages intermédiaires sont 223, ou bien si la page finale est
223, alors les avions se sont perdus de vue. Chaque joueur décide alors de continuer le
combat ou de s'éclipser. Si les deux avions fuient, c'est un match nul. Si les deux
avions décident de continuer, le combat reprend sur une page avec une position neutre, chaque avion
conservant les dégâts déjà subis. Si un seul avion fuit, il accorde une demi-victoire
à son adversaire, mais c'est parfois préférable, plutôt que de prendre le risque de se
faire descendre et d'accorder ainsi une victoire complète à son adversaire.

=head3 Autre cas particulier, la poursuite

Lorsqu'un avion est dans le quadrant arrière d'un autre (4 à 8 heures) et que
son cap est identique ou presque, alors on dit qu'il poursuit l'autre avion.
C'était le cas sur la page 1 présentée ci-dessus. Pour des raisons pédagogiques,
j'ai préféré faire le silence sur cette particularité.
La simultanéité du choix des manœuvres est partiellement annulée. La séquence est la suivante

=over 4

=item 1 L'avion poursuivi choisit une manœuvre.

=item 2 Il indique au poursuivant s'il s'agit d'une manœuvre vers
la gauche, d'une manœuvre vers la droite ou d'une manœuvre en ligne droite
vers l'avant. Il ne donne pas le numéro de la page intermédiaire.

=item 3 L'avion poursuivant choisit une manœuvre.

=item 4 Les deux joueurs annoncent simultanément les pages intermédiaires.

=item 5 Les deux joueurs déterminent la page finale.

=back

=head3 Altitude

Le jeu met en scène des avions, donc on tient compte de l'altitude, n'est-ce S<pas ?>
Non, pour les règles de base, le jeu se contente
d'L<utiliser deux dimensions|https://tvtropes.org/pmwiki/pmwiki.php/Main/TwoDSpace>.
Il y a juste un cas où l'altitude a un rôle à jouer. Il y a six pages correspondant
au cas où les deux avions sont dans le même hexagone. Dans ce cas, on convient qu'il
sont séparés par quelques mètres d'altitude. C'est ce que disent les joueurs, la règle
est muette à ce sujet.

Il y a des règles avancées, dont une qui demande de noter l'altitude à chaque tour
de jeu. C'est beaucoup d'effort pour un gain mineur, le jeu n'en vaut pas la chandelle.

=head3 Considérations diverses

Lors d'un tour de jeu, vous devez garder à l'esprit :

=over

=item 1 le numéro de la page initiale,

=item 2 la manœuvre choisie

=item 3 la page intermédiaire que vous communiquez à votre adversaire,

=item 4 la page intermédiaire que votre adversaire vous indique,

=item 5 la page finale du tour,

=item 6 le nombre de points de dégâts encaissés,

=item 7 optionnellement le nombre de points de dégâts infligés à votre adversaire.

=back

On dit que la mémoire à court terme d'un humain contient 7 ± 2 informations (à part les serveurs
de café, qui dépassent largement cette valeur). À moins d'être
dans la catégorie inférieure, il est possible de jouer à l'I<As des As> sans avoir besoin
de noter quoi que ce soit, ni de déplacer des marqueurs sur des tableaux. Il est possible
de jouer à la plage, il est possible de jouer à côté de la machine à café,
il est possible de jouer dans une salle d'attente, il est possible
de jouer dans le bus. Et si vous êtes dans une catégorie supérieure pour cette faculté,
vous pouvez même jouer dans le bus tout en gardant un œil sur les arrêts restants avant
votre destination.

=head2 Extensions

Deux extensions sont sorties avec des avions plus récents
(I<L<Powerhouse|https://boardgamegeek.com/boardgame/7104/ace-aces-powerhouse-series>>,
Spad XIII contre Fokker D.VII) ou plus anciens
(I<L<Flying Machines|https://boardgamegeek.com/boardgame/7103/ace-aces-flying-machines>>,
Airco DH2 contre Fokker E.III). Également, il y a la version Seconde Guerre Mondiale 
(I<L<Wingleader|https://boardgamegeek.com/boardgame/6504/ace-aces-wingleader>>, 
P-51 Mustang contre FW190), la version Guerre Froide
(I<L<Jet Eagles|https://boardgamegeek.com/boardgame/1991/ace-aces-jet-eagles>>,
F-15 Eagle contre MiG-29 Fulcrum) et 
même la version Guerre des Étoiles
(I<L<Starfighter Battle Book|https://boardgamegeek.com/boardgame/3152/star-wars-starfighter-battle-book>>,
X-Wing contre TIE-Fighter, extension publiée par West End Games).

À remarquer que toutes ces versions ont la même pagination. Dans tous les livrets, la page 96 montre
le « méchant » derrière le « gentil », à distance moyenne, avec le même cap et en train de lui tirer dessus.
Il est possible de jouer avec un livret « gentil » d'un jeu et un livret « méchant » d'un autre jeu, quitte
à faire combattre un X-Wing contre un Fokker E.III ! Ou vous contenter d'un duel F-15 contre FW190, 
ce qui vous rappelera le 
L<célèbre accrochage|https://www.youtube.com/watch?v=f3XNEWtJF0o>
entre deux F-14 et deux A6M2 Zéro.

Juste quelques hics, l'échelle des distances n'est pas la même d'un jeu à l'autre et les
points de dégâts n'ont rien à voir. Il vous faudra une bonne dose de
L<suspension délibérée de l'incrédulité|http://tvtropes.org/pmwiki/pmwiki.php/Main/WillingSuspensionOfDisbelief>
pour les parties de ce S<type !>

Et vous ne pouvez pas opposer un S<« gentil »> à un autre S<« gentil »>, par exemple un F-15 à un P-51,
ni faire combattre un S<« méchant »> avec un autre S<« méchant »>, par exemple un Fokker D.VII
contre un FW190.

Attention au sujet de I<Wingleader> : il existe un 
L<autre jeu|https://boardgamegeek.com/boardgame/160418/wing-leader-victories-1940-1942>
beaucoup plus récent du
même nom chez GMT. Si vous êtes intéressé par le jeu décrit et que vous voulez l'acheter
par correspondance, vérifiez bien qu'il s'agit du bon jeu.

=for html
<img src='As-des-As-Wingleader-Jet-Eagles.png' alt="L'As des As,  Première Guerre Mondiale, Seconde Guerre Mondiale et Guerre Froide" />

I<Photos personnelles. Les conditions de licence sont les mêmes que pour le texte.>

=for html
<img src='Jet-Eagles-96.png' alt="Page 96 pour Jet Eagles, livret 'Red Force' et  livret 'Blue Force'" />

I<Photos personnelles reprenant une page dans les deux livrets de Jet Eagles, copyright © 1990 Nova Game Designs, Inc.>

Toutes ces variantes proposent également des règles avancées, pour
l'altitude par exemple, ou le jeu 2-contre-2, ou
encore pour les radars et les missiles dans le cas de I<Jet Eagles>.
Hélas, ces règles avancées font perdre la compatibilité avec la capacité 7 ± 2 de la mémoire à court terme.
À part une règle sur la compatibilité entre deux manœuvres successives
d'un même avion, je n'ai pas l'intention de les prendre en compte dans
mes programmes.

Il y a également une extension 
I<L<Balloon Buster|https://boardgamegeek.com/boardgame/5736/ace-aces-balloon-buster>>
où l'on fait du 2-contre-1. Le joueur allemand contrôle un ballon d'observation
(assez passif) plus un canon anti-aérien, contre un avion britannique.

Autres extensions dans la même lignée, mais impossibles à mélanger avec les premières :
I<L<Shootout at the Saloon|https://boardgamegeek.com/boardgame/3089/bounty-hunter-shootout-saloon>>
traduit chez Gallimard avec le titre I<Le shérif et le hors-la-loi>,
I<L<Dragons Riders of Pern|https://boardgamegeek.com/boardgame/5735/dragonriders-pern-book-game>>
traduit par Gallimard avec le titre I<les Maîtres des Dragons>
et une série dont je n'avais jamais entendu parler avant de rédiger ces explications,
I<L<Lost Worlds|https://boardgamegeek.com/boardgame/3969/lost-worlds-adventure-set-i-ruins-ancients>>.

=for html
<img src='Le_sherif_et_le_hors-la-loi.png' alt="Le Shérif et le Hors-la-loi" />

I<Photos personnelles reprenant « Le Shérif et le Hors-la-loi », Copyright © 1982 Nova Games Design Inc, copyright © 1986 Emithill Limited,
copyright © 1986 Gallimard pour la traduction française et pour les illustrations de couverture.>

=begin html

<img src='Mai-68-A.jpg' alt="Mai 68, première édition" width='45%' />
<img src='Mai-68-B.jpg' alt="Mai 68, deuxième édition" width='45%' />

=end html

I<Photos personnelles reprenant le jeu "Mai 68" de F. Nédelec et D. Vitale, Copyright © 1980, 1982, 1988>

Oups ! Qu'est-ce que cela vient faire dans cet exposé sur le centenaire de la RAF et sur
le centenaire de S<l'armistice ?> Est-ce que Danny le Rouge a évincé le Baron S<Rouge ?>

Pour en revenir au combat aérien, puisque le brevet est tombé dans le domaine public,
n'importe qui peut publier des extensions dans la lignée :

=over 4

=item * Apache AH-64 vs Mi-24 Hind

=item * Quidditch : Griffindor vs Slytherin

=item * Superman vs Ironman

=item * Épervier vs drone de loisir

=back

C'est d'ailleurs cette dernière extension que j'ai choisie pour disposer de données
de tests dans mes programmes. J'étais réticent à reprendre les caractéristiques des
avions de l'un des jeux existants, car si le brevet est expiré, le copyright ne l'est pas.

=head1 L'As des As, description des programmes

Lorsque j'ai découvert le jeu, je me suis dit que finalement, ce jeu consistait à combiner des
nombres (les numéros de page) et des symboles (les manœuvres) pour obtenir d'autres nombres.
L'image figurant sur chaque page a  pour but d'aider le joueur humain à choisir le bon symbole
de manœuvre, du moment que ce joueur a une idée suffisamment précise du vol d'un avion et qu'il connaît
les Dicta Boelke, les conseils de Sailor Malan, l'ouvrage I<No Guts, No Glory> de S<« Boots »> Blesse
et autres écrits du même genre. Il est possible d'enlever tout cet habillage aéronautique pour ne
conserver que le mécanisme abstrait reposant sur un automate à états finis éventuellement mâtiné 
d'une dose de fonction I<random>. D'où l'idée d'un programme jouant à ce jeu sans rien connaître
du contexte réel, mais se basant uniquement sur une analyse statistique des parties passées.

Il y a deux grandes parties dans le projet. Tout d'abord, la préparation,
consistant à produire les livrets sous forme électronique, en générant les fichiers
plutôt qu'en tapant la totalité des enchaînements entre pages
et manœuvres. Puis il y a le jeu proprement dit où des programmes combattent
l'un contre l'autre et tirent la leçon de leurs combats passés.

=head2 Préparation

J'ai commencé par programmer cette partie, bien sûr. Je l'ai faite avant d'initialiser
le dépôt Git. Du coup, les programmes étaient dans un répertoire extérieur.
Ces programmes ont été réintégrés après coup dans le dépôt Git, avec une
phase de nettoyage. Vous ne verrez donc pas mes tout premiers pas en Perl 6.

Les programmes de ce dossier tiennent compte de la géométrie sous-jacente des pages.
Dans un premier temps, en se basant sur un seul livret de la série, on cherche à
retrouver l'interprétation de chaque page sur la grille hexagonale implicite.
On commence par charger la base de données avec une page codée S<« en> S<dur »>, 
plus la page spéciale 223. Ensuite, le processus est itératif. On prend une page
déjà référencée dans la base de données, puis on fournit au programme la liste des
transitions manœuvres → page d'arrivée de cette page de départ. Cela permet de
définir à quel hexagone et à quelle orientation ces pages d'arrivée correspondent.
Au bout d'un certain temps, on a passé en revue toutes les pages du livret et donc
on connaît la grille hexagonale entière.

Dans un deuxième temps, on initialise un fichier JSON avec les manœuvres d'un avion,
on croise avec la base de données de la première étape, et on génère un livret 
donnant la liste des transitions page de départ + manœuvre → page d'arrivée.
Ce livret est codé sous la forme d'un fichier JSON avec en prime un fichier HTML.

Vous en saurez plus en lisant la
L<documentation|https://github.com/jforget/Perl6-Alpha-As-des-As-Zero/blob/master/Preparation/description-fr.pod>
particulière de cette étape.

=head2 Jeu

Le jeu entre humains est prévu pour deux joueurs sans arbitre.
Pour les programmes, j'ai préféré utiliser un programme arbitre,
ou plutôt un processus arbitre,
communiquant avec deux processus joueurs. Les deux processus
joueurs fonctionnent avec le même programme Perl 6, mais avec des
arguments d'appel différents.

Pour rester dans la même optique que Google Alpha Go Zero et Google Alpha Chess Zero,
le programme joueur n'a aucune connaissance intrinsèque des mécanismes de vol
et des doctrines de combat aérien. Il se contente de recevoir une liste
de manœuvres de l'arbitre, d'en sélectionner une et de renvoyer la réponse
à l'arbitre.

Le programme joueur fonctionne en deux modes. Il y a le mode entraînement
où le choix est totalement aléatoire. Et il y a le mode combat où le
programme joueur extrait de la base de données les situations analogues
pendant les parties précédentes pour savoir ce qui a bien marché et
ce qui n'a pas donné de bons résultats. Il attribue des probabilités 
plus ou moins élevées aux
différentes manœuvres proposées par le programme arbitre et tire au
hasard une manœuvre, en tenant compte de la loi de probabilité attribuée.

J'ai choisi une méthode aléatoire pour le choix des manœuvres, de manière
à éviter d'aboutir à un jeu stéréotypé, chaque programme joueur faisant
un calcul de minimax sur les manœuvres pour toujours obtenir le même choix
dans la même situation. Avec un tirage aléatoire, la meilleure solution 
est celle qui a la plus forte probabilité, mais cela n'exclut pas de temps
en temps de choisir une manœuvre inhabituelle S<« pour> dérouter S<l'adversaire »>
(non, l'argument est foireux dans le cas d'un combat programme contre programme).

Le programme arbitre, lui, a une meilleure connaissance des mécanismes
de vol et de tir, mais rien sur la tactique ni la doctrine.
C'est lui qui lit le fichier JSON créé par les programmes de préparation
et qui connaît ainsi à quelle page on aboutit lorsque l'on exécute
telle manœuvre sur telle page de départ. Ce qui ne veut pas dire qu'il
connaît la géométrie sous-jacente, il se contente d'utiliser le fichier
JSON comme une table de transitions page de départ + manœuvre → page d'arrivée.

=head3 Base de données

Le choix de la base de données 
L<MongoDB|https://www.mongodb.com/fr>
s'appuie sur les mêmes raisons que celles
que j'ai données lors de ma présentation aux Journées Perl 2017. J'en sais déjà
suffisamment sur les manipulations de données en SQL, alors que j'ai plus à découvrir
avec les bases NoSQL. Il aurait été possible d'écrire les programmes avec une base
de données
L<SQLite|https://sqlite.org/index.html>
ou une autre base SQL, mais je trouvais cela moins intéressant.

Lors de ma présentation, on m'a fait remarquer que MongoDB permet de stocker des
images, ce qui est intéressant pour un jeu tel que l'As des As, basé sur des images
représentant des avions. Le stockage des images n'a pas joué dans mon choix de MongoDB.
Je n'ai jamais eu l'intention de recopier les images dans la base de données.

Notons que certaines données sont  stockées dans un fichier texte avec
la  syntaxe  S<JSON :>  les  caractéristiques  des avions.  Au  début,
c'était  la même  chose  pour  les pilotes,  qui  figuraient dans  des
fichiers  JSON. Puis  je  me suis  dit que  c'était  plus facile  dans
certains cas si les pilotes étaient  stockés dans une collection de la
base MongoDB,  en plus du fichier  JSON. Donc j'ai écrit  un programme
C<init-pilote> qui lit  le fichier JSON décrivant un pilote  et qui le
convertit en objet Raku et le  stocke dans la collection C<Pilotes> de
la base  de données. Et dans  mon élan, j'ai écrit  un autre programme
C<init-avion> qui  lit le fichier  JSON décrivant  un avion et  qui le
stocke dans  la collection C<Avions> de  la base de données.  De plus,
pour les besoins  des parties d'entraînement, j'ai  besoin pour chaque
avion d'un pilote anonyme identifié par  la même clé que l'avion. Dans
le programme d'initialisation  de l'avion, j'en profite  pour créer ce
pilote  anonyme  dans  la  collection C<Pilotes>.  Les  fichiers  JSON
continuent   à  exister,   mais   ils  sont   utiles  seulement   pour
l'initialisation.

Il y  a un problème  à la  relecture des enregistrements  C<Avions> et
C<Pilotes>. Alors que  le module C<JSON::Class> permet  de générer des
objets des classes  C<Avion> et C<Pilote> à partir  d'une chaîne JSON,
les  modules   pour  MongoDB  se   contentent  de  créer   des  objets
C<BSON::Document> et il faut utiliser la  syntaxe des  tables de
hachage pour accéder aux informations des avions et des pilotes.
Il n'y a pas de conversion directe vers la classe C<Avion> ou
vers la classe C<Pilote>. Ou alors, il faut écrire un constructeur qui
extrait  chacune  des  valeurs  du hachage  C<BSON::Document>  et  qui
alimente l'attribut  correspondant de  l'objet C<Pilote>  ou C<Avion>.
Quelle solution simple et propre apporter à ce S<problème ?>

En  programmation, il  existe un  dicton  S<« Tout>  problème peut  se
résoudre en ajoutant un niveau S<d'indirection »>. C'est un peu ce que
j'ai  fait ici.  Lorsque le  programme crée  un document dans la collection  C<Avions> ou
C<Pilotes> de  la base de  données, ce document contient  une entrée
C<json> qui stocke la chaîne JSON brute ayant servi à créer l'objet de
la classe C<Avion> ou C<Pilote>. Dans le programme suivant, lorsque je
lis le document BSON, je m'intéresse uniquement à cette entrée C<json>
et je  la transmets à  la méthode C<from-json> du  rôle C<JSON::Class>
qui crée  ainsi de véritables  objets C<Avion> ou C<Pilote>.  Dans les
documents de  la base  de données,  il y a  juste besoin  d'une entrée
C<identité>  servant  de   clé  et  d'une  entrée   C<json>  pour  les
informations utiles. J'ai quand même ajouté d'autres entrées reprenant
les attributs des objets (pas tous), pour le cas où j'en aurais besoin
lors des recherches en base de données.

D'un autre  côté, pour  les parties  et les coups  (ou tours  de jeu),
j'utilise des C<BSON::Document> bruts de fonderie dans les collections
C<Parties> et C<Coups>. Ce n'est pas très cohérent, il est vrai.

=head3 Communication inter-processus

Ainsi donc, il y a trois processus qui s'échangent des informations.
Ai-je eu recours à des sockets ? À des messages mis en file d'attente ?
Non. Je me suis inspiré d'un mécanisme que l'on voit couramment
dans les romans d'espionnage de John le Carré ou du même style,
la S<« boîte> aux S<lettres »>. L'officier traitant donne ses instructions
sur un microfilm qu'il dépose dans un endroit discret S<convenu :>
souche d'arbre, fissure entre deux briques, vous voyez le genre.
L'espion récupère le microfilm, effectue les recherches demandées
et livre les résultats au même endroit. Et l'officier
traitant récupère les documents secrets de la même manière. C'est pareil entre
le processus arbitre et les processus joueurs. L'arbitre écrit dans
la base de données un enregistrement pour chaque joueur.
Le processus joueur lit l'enregistrement qui le concerne, le met
à jour et le réécrit dans la base. Puis l'arbitre lit l'enregistrement
modifié.

Comme dans les romans de John le Carré, si un processus ne trouve pas
l'enregistrement attendu dans la boîte aux lettres, il attend un petit peu
et il refait une tentative de lecture. Et comme dans les romans de John le Carré,
au bout d'un nombre important de tentatives infructueuses, le processus considère qu'il s'est passé
quelque chose de louche et il arrête toute activité. La métaphore s'arrête là, car
d'un côté l'espion se fait exfiltrer et survit, de l'autre côté le processus
effectue un C<die>.

S<« Quand> on a un marteau, tout ressemble à un S<clou. »> Certes, mais en procédant de
la sorte, je n'avais qu'un seul module pour lequel je pouvais avoir des problèmes
qu'il fallait contourner, soit des bugs, soit des 
L<PECEC|https://fr.wiktionary.org/wiki/entre_la_chaise_et_le_clavier>.

=head3 Programme C<arbitre.p6>

Le programme commence, bien sûr, par une étape d'initialisation où les
principales variables sont initialisées. Rien de spécial à noter.

Ensuite, c'est la boucle événementielle, qui enchaîne les tours de jeu.
Cette boucle contient les étapes S<suivantes :>

=over 4

=item 1  Résolution des  tirs du coup  précédent et  détermination des
choix accessibles aux deux joueurs pour le tour en cours.

=item 2 Écriture dans la collection C<Coups> des choix proposés aux deux joueurs.

=item 3 Lecture dans la collection C<Coups> de la réponse de chaque joueur.

=item 4 Application des transitions page initiale → page intermédiaire → page finale.

=item 5 Détection de la fuite d'un avion ou des deux.

=item 6 Traitement de la fin de partie (fuite ou destruction).

=back

=head4 Résolution des tirs

La résolution du tir du tour I<n> se fait en réalité lors de l'étape 1
du tour I<n>+1.  S<Pourquoi ?> Parce que les  tirs n'entraînent aucune
décision de la part des joueurs.  Il est donc inutile de déclencher un
mécanisme d'échange  par boîte  aux lettres pour  les tirs,  il suffit
d'attendre le tour  suivant et la procédure de choix  de manœuvre pour
que l'arbitre signale  au joueur combien de points de  dégâts il vient
de  perdre.  C'est  peut-être   anti-intuitif,  mais  cela  permet  de
simplifier les programmes.

Évidemment, si lors de l'étape 1 on détecte la destruction d'un avion,
les étapes 2 à 5 sont automatiquement sautées et on traite directement
l'étape 6.

=head4 Poursuite

Dans le cas d'une poursuite, les étapes 2 et 3 sont séparées entre les
deux joueurs. Cela donne S<alors :>

=over 4

=item * 2A Écriture dans la collection C<Coups> des choix proposés au joueur poursuivi.

=item * 3A Lecture dans la collection C<Coups> de la réponse du joueur poursuivi.

=item * 2B Écriture dans la  collection C<Coups> des choix proposés au
joueur poursuivant, avec  indication G/A/D de la  manœuvre choisie par
le poursuivi.

=item * 3B Lecture dans la collection C<Coups> de la réponse du joueur poursuivant.

=back

Lorsque le programme  arbitre demande sa prochaine  manœuvre à l'avion
poursuivant, il lui communique un  numéro de page sous forme spéciale,
le  véritable numéro  de page  concaténé avec  la direction  G/A/D. En
reprenant l'exemple tiré du brevet, l'avion britannique est page B<1>,
tandis que l'avion allemand est page  B<1G>, pour tenir compte du fait
que le britannique a choisi une manœuvre vers la gauche. Les pages 1G,
1A et 1D ont exactement les  mêmes transitions manœuvre → page finale,
mais le joueur allemand a  trois différents groupes de S<« situations>
S<antérieures »>  pour choisir  sa manœuvre  suivante selon  qu'il est
page  B<1G>, page  B<1A> ou  page B<1D>.  Cela simplifie  le programme
joueur, qui n'a  aucune procédure spéciale pour la  poursuite, au prix
d'une  légère complexification  du programme  arbitre (qui  doit tenir
compte de la lettre G/A/D à la suite du numéro de page, qui n'est plus
tout-à-fait numérique).

=head4 Liste des manœuvres disponibles

Cette étape ne  devrait pas donner lieu à commentaires.  Si vous jetez
un  coup d'œil  ci-dessous,  dans le  paragraphe  de conclusion,  vous
verrez que  j'ai prévu un  mode I<à outrance>  où, dans le  cadre d'un
entraînement,  les avions  cherchent  à continuer  le  combat le  plus
longtemps  possible. Lorsque  cette  option est  active, le  programme
arbitre filtre les manœuvres qu'il autorise aux programmes joueurs, il
supprime toutes les manœuvres conduisant à une page intermédiaire 223.
Cas particulier, si I<toutes> les  manœuvres conduisent à la page 223,
alors le programme arbitre les laisse telles quelles.

Il n'est pas possible en revanche d'éliminer les situations où la page
finale est la page 223. Par  contre, dans ce cas, le programme arbitre
propose aux programmes  joueurs un choix avec 4 fois  l'attaque et une
seule fois la fuite. Cela permet de favoriser la reprise du combat. La
probabilité est en effet 16/25 au lieu de 1/4.

Il est possible que ce  filtrage induise un biais dans l'apprentissage
des  programmes joueurs.  D'un autre  côté, cela  enrichit la  base de
connaissances,  car   cela  donne  des  parties   d'entraînement  avec
plusieurs  dizaines  de tours  de  jeu,  plutôt  que des  parties  qui
s'interrompent après une demi-douzaine de coups.

=head4 Fin de partie

Lorsque l'arbitre détecte la fin de  la partie, soit parce qu'au moins
un avion a encaissé autant ou plus  de points de dégâts que son niveau
initial, soit parce qu'au moins un  avion décide de fuir, le programme
écrit un enregistrement C<Coups> ultime  pour chacun des joueurs, avec
l'attribut C<fini> à 1 et le résultat en PV (+1, -1, +1/2 ou -1/2). De
sorte, les processus  joueurs savent que la partie est  finie et qu'il
faut quitter la boucle d'événements.

En outre,  le programme arbitre écrit  un enregistrement récapitulatif
dans la collection C<Parties>.

=head3 Programme C<joueur.p6>

Le  programme  C<joueur.p6> est  basé  sur  une  boucle où,  à  chaque
itération, il  lit un coup dans  la collection C<Coups> et  le réécrit
pour indiquer à l'arbitre la manœuvre sélectionnée.

Chaque joueur a  deux attributs numériques, utilisés pour  le choix de
la manœuvre suivante, la  I<psycho-rigidité> et la I<perspicacité>. La
psycho-rigidité  est un  nombre flottant  supérieur  ou égal  à 1,  la
perspicacité est un nombre flottant entre 0 et 1.

Voici les différentes étapes pour un tour de jeu.

=head4 Recherche des situations similaires

Le  programme  extrait  de  la collections  C<Coups>  tous  les  coups
vérifiant les conditions S<suivantes :>

=over 4

=item  1 Même  page.

=item 2 Partie antérieure (en se  basant sur la clé date-heure).

=item 3 Même pilote ou simplement pilote similaire.

=back

Reprenons les critères.

Même  S<page :>  rappelez-vous que  dans le  cas d'une  poursuite, par
exemple page  1 comme  nous l'avons  vu plus  haut, le  poursuivant ne
mélange pas la page B<1G> avec la page B<1A> ni avec la page B<1D>.

Partie S<antérieure :>  on ne tient pas compte de  la partie en cours,
pour  la simple  raison que  l'on ne  connaît pas  encore le  résultat
final. On ne tient pas non  plus compte des parties futures. Cela peut
paraître bizarre de préciser cela, car  les parties ne sont pas encore
jouées. Ce critère sert en fait  pour la page du site web récapitulant
le tour de  jeu, page qui peut être consultée  plusieurs mois après la
partie  elle-même,  donc  ce   critère  nous  permet  de  reconstituer
fidèlement le processus  décisionnel ayant conduit à  la résolution du
tour de jeu.

Même pilote ou  pilote S<similaire :> un pilote se  base sur sa propre
expérience. Il se  base également sur les enseignements  qu'il a reçus
de  ses  instructeurs  et   de  ses  camarades  d'escadrille.  Prenons
l'exemple de Guynemer sur SPAD  XIII. Il s'appuiera sur ses précédents
combats, mais aussi sur les entraînements de pilotes anonymes sur SPAD
XIII. Et même,  il pourra se baser sur l'expérience  accumulée par ses
instructeurs comme  Jules Védrines ou  Paul Tarascon. C'est le  but de
l'attribut C<@ref>  des enregistrements  de la  collection C<Pilotes>.
Guynemer extraira les coups avec  une C<identité> faisant partie de la
S<liste :>

  < Guynemer SPAD_XIII Vedrines Tarascon >

(en notation Raku).

Pour que cela soit cohérent, il faut bien sûr que Védrines et Tarascon
aient  eux aussi  volé  sur SPAD  XIII.  Cela dit,  on  peut, à  titre
expérimental,  regarder ce  que donnerait  un  pilote qui  a appris  à
piloter sur un Fokker E.III et se retrouve affecté à une Jasta équipée
de Fokker D.VII.

Autre remarque,  bien que l'attribut  C<ref> existe en version  V1, il
n'est pas  utilisé et Guynemer se  contente des coups provenant  de la
S<liste :>

  < Guynemer SPAD_XIII >

Dernière S<remarque :> lors de l'extraction des situations similaires,
le programme pilote ne tient pas  compte de la nature de l'ennemi. Par
exemple, si  la partie en  cours oppose un  Sopwith Camel à  un Fokker
Dr1.  le  programme  incarnant  le Camel choisira aussi bien les coups
S<« Camel>  contre S<Dr1 »>  que  les coups  S<« Camel>  contre Fokker
S<E.III »> et les coups S<« Camel> contre Fokker S<D.VII »>.

=head4 Évaluation des situations similaires extraites

S<«  Perspicacité »>  signifie S<«  voir>  à S<travers  »>. À  travers
S<quoi ?> À travers les brumes du  temps dans notre cas. Si une partie
se termine au  tour 15, un joueur perspicace estimera  que la manœuvre
choisie au  tour 10 a  pu avoir une  influence sur le  résultat final,
tandis qu'un joueur  peu perspicace estimera que seule  la manœuvre du
tour 14 aura pu avoir une influence, ou bien à la rigueur, à l'extrême
rigueur, celle du tour 13.

Comment  cela se  traduit-il  en termes  de  S<programmation ?>  Voici
quelques exemples, qui vous permettront de deviner la règle S<générale :>

     Résultat       dernier       tour
      final          tour        actuel     perspicacité  évaluation
      1 VP            15           10             0,1       0,00001
     -1 VP            15           10             0,1      -0,00001
      1 VP            15           14             0,1       0,1
      0,5 VP          15           14             0,1       0,05
      1 VP            15           10             0,5       0,03125
      1 VP            15           14             0,5       0,5
      1 VP            15           10             0,9       0,59049
     -1 VP            15           14             0,9      -0,9
     -0,5 VP          15           14             0.9      -0,45

=head4 Évaluation des manœuvres

Pour  une  manœuvre  donnée,   le  programme  sélectionne  toutes  les
situations  antérieures ayant  été suivies  par la  manœuvre en  cours
d'examen et il additionne les évaluations de ces manœuvres. Non, on ne
fait pas la  moyenne, on fait la  somme, ce qui donne,  en théorie, un
nombre dans la plage de moins l'infini à plus l'infini.

=head4 Choix de la manœuvre

C'est  à  ce  moment   qu'intervient  la  psycho-rigidité.  Un  pilote
psycho-rigide préférera  de loin choisir B<la>  manœuvre la meilleure,
de préférence à  n'importe quelle autre. Un pilote un  peu plus souple
choisira, de temps en temps, une manœuvre qui n'est pas optimale, mais
qui peut ouvrir des horizons inhabituels.

Le programme affecte des S<« poids »> à chaque manœuvre, en prenant la
psycho-rigidité du pilote et en l'élevant à la puissance correspondant
à l'évaluation de la manœuvre. Une fois les poids calculés pour toutes
les  manœuvres, le  programme  les  normalise pour  avoir  une loi  de
probabilité. Pour faciliter le tirage  au sort, le programme convertit
cette  loi  de  probabilité  en fonction  de  répartition.  Enfin,  le
programme tire  un nombre pseudo-aléatoire dans  l'intervalle 0..1, le
croise avec la fonction de répartition  et en déduit la manœuvre tirée
au sort.

C'est  plus clair  avec quelques  exemples. Supposons  que nous  ayons
trois manœuvres, avec respectivement les  évaluations -2, 1 et 2. Pour
un premier pilote, très psycho-rigide (10), nous avons

  manœuvre  évaluation  poids    probabilité   répartition
      A        -2         0,01      0,000091    0,000091
      B         1        10         0,090901    0,090992
      C         2       100         0,909008    1
    total               110,01      1,000000

Si  le  nombre  aléatoire  tiré  est dans  l'intervalle  de  9,1e-5  à
0,090992,  on  prendra la  manœuvre  B.  Si  ce nombre  aléatoire  est
supérieur à 0,090992,  alors c'est la manœuvre C. Enfin,  dans les cas
rarissimes où le  nombre est inférieur à 9,1e-5, on  prend la manœuvre
A.

Avec  les  mêmes manœuvres,  prenons  maintenant  un pilote  très  peu
psycho-rigide (1,1). Les différents calculs S<donnent :>

  manœuvre  évaluation  poids       probabilité  répartition
      A        -2         0,826446   0,2634976   0,2634976
      B         1         1,1        0,35071543  0,61421303
      C         2         1,21       0,38578697  1
    total                 3,136446   1,00000000

Ainsi qu'on  peut le  voir, les trois  manœuvres ont  des probabilités
voisines  d'un  tiers,  avec  quand  même  une  légère  mais  sensible
préférence pour la manœuvre C.

=head4  Parties d'entraînement

Si vous  baissez la psycho-rigidité  jusqu'à 1, vous voyez  sans peine
que  toutes les  manœuvres ont  la  même probabilité,  peu importe  le
nombre de situations antérieures où  elles apparaissent et quel fut le
résultat final  de la partie.  Donc, pour les  parties d'entraînement,
j'utilise des pilotes anonymes avec une psycho-rigidité de 1. De plus,
lorsque le programme C<pilote.p6>  constate que la psycho-rigidité est
à 1, il ne se fatigue pas à extraire les situations antérieures, à les
évaluer  et à  mouliner les  nombres obtenus.  Il prend  la liste  des
manœuvres disponibles et  en tire une au sort  (instruction C<pick> de
Raku).

=head4 Fin de partie

Lorsque  le  programme  C<pilote.p6>  lit un  document  C<Coups>  avec
l'attribut C<fini>  à 1, il sait  que la partie est  terminée et qu'il
faut s'arrêter. Toutefois,  juste avant d'arrêter, le  programme met à
jour tous les coups de la partie pour y mémoriser le résultat final et
le nombre de tours entre ce coup et  la fin de la partie. De la sorte,
lors des prochaines parties, cela économisera le nombre de documents à
lire en base de données.

=head2 Conclusion : Retour d'expérience sur l'As des As

Un  point qui  m'a  surpris et  auquel j'aurais  pu  penser, c'est  la
réaction  des pilotes  en page  223 en  mode combat.  Le but  était de
permettre à  un avion déjà bien  amoché de fuir pour  survivre et pour
n'accorder  qu'un  demi-point de  victoire,  au  lieu de  continuer  à
combattre avec un  net désavantage et d'accorder un  point de victoire
entier à l'ennemi. Pourtant, le pilote a quasiment toujours tendance à
rester, même si la situation est désespérée.

Ce qui se  passe en réalité, c'est  que le choix de la  fuite donne en
moyenne  un résultat  S<négatif  :> -0.5  PV  si l'adversaire  préfère
continuer le  combat, 0  PV si l'adversaire  souhaite lui  aussi fuir,
soit -0,25  PV en moyenne. En  revanche, la poursuite du  combat donne
autant  de chances  de gagner  le  combat que  de le  perdre. Donc  en
moyenne, un résultat nul, meilleur que  la moyenne des résultats de la
fuite. Il n'y a pas de  distinction entre les cas désepérés où l'avion
n'a plus qu'un point  de dégâts ou deux et les  cas confortables où il
lui reste 11 points de dégâts. C'est ainsi que les pilotes sont amenés
à choisir la poursuite du combat.

Ce qu'il faudrait faire, c'est moduler la note des résultats antérieurs
en comparant le potentiel restant de la situation actuelle et celui de ces
coups antérieurs. Si un pilote est en page 223 avec tout juste 2 points de
vie sur les 12 initiaux, on privilégiera les coups antérieurs avec 1, 2 ou
3 points de vie, tout en minimisant l'importance des coups antérieurs avec
8 points de vie ou plus. De la sorte, peut-être que les pilotes préféreront
fuir.

D'un autre côté, en mode entraînement, cela ne vaut pas le coup de fuir, car
cela écourte la séance d'entraînement et cela réduit les informations disponibles
pour les combats ultérieurs. J'ai donc créé une option S<« à outrance »> où le
choix de l'attaque est privilégié par rapport à la fuite.

=head1 Perl 6

=head2 Installation

Je connais quatre méthodes pour installer Rakudo Star sur une machine Linux.

=over 4

=item 1

Installer le paquet F<.rpm> ou F<.deb> fourni par votre distribution.

=item 2

Installer le paquet F<.rpm> ou F<.deb> fourni par un L<volontaire|https://github.com/nxadm>
dans un L<dépôt Github|https://github.com/nxadm/rakudo-pkg/releases>

=item 3

Récupérer une image Docker, comme le propose Moritz Lentz dans son livre I<Perl 6 Fundamentals>.

=item 4

Compiler à partir des sources.

=back

Dans mon cas, la deuxième méthode est inapplicable (pas de paquet pour
xubuntu 16.10) et la première méthode donne des versions vraiment trop
anciennes. Mes différentes machines physiques et virtuelles et les
paquets correspondants sont :

  physique    xubuntu-12.04   32 bits  rakudo 2011.07
  virtuelle   xubuntu-14.10   32 bits  rakudo 2013.12
  virtuelle   lubuntu-15.10   32 bits  rakudo 2014.07
  physique    xubuntu-16.10   64 bits  rakudo 2016.06
  virtuelle   Mageia-5        32 bits  pas trouvé

Pour Docker, il faudrait d'une part que Docker soit installé sur ma machine, d'autre
part que je sois à l'aise avec Docker. Or Docker n'est pas installé et les dépôts xubuntu 16.10
ne sont plus disponibles depuis un certain temps. Et je ne maîtrise pas l'utilisation
de Docker.

Du coup, j'ai installé rakudo star 2018.01 à partir des sources. La première fois que
j'ai compilé rakudo star, cela a pris beaucoup de temps, plusieurs heures.
La deuxième fois, pour éviter d'avoir à surveiller ma machine pour saisir les
commandes l'une après l'autre (C<make>, C<make test>, C<make install>), j'ai écrit un script
qui enchaîne ces commandes et donne la date et l'heure entre deux.

  #!/bin/sh
  # -*- encoding: utf-8; indent-tabs-mode: nil -*-

  interlude() {
    echo
    echo
    date +'%Y-%m-%d %H:%M:%S'
    echo
    echo
  }

  mkdir ~/rakudo && cd $_
  wget https://rakudo.perl6.org/downloads/star/rakudo-star-2018.01.tar.gz
  interlude
  tar -xvzf rakudo-star-2018.01.tar.gz
  interlude
  cd rakudo-star-2018.01/
  interlude
  perl Configure.pl --backend=moar --gen-moar
  interlude
  make
  interlude
  # If you wish, you can run the tests
  # Depending on your machine, they could take over half an hour to run
  make rakudo-test
  interlude
  make rakudo-spectest
  interlude
  make install
  interlude
  echo "export PATH=$(pwd)/install/bin/:$(pwd)/install/share/perl6/site/bin:\$PATH" >> ~/.bashrc
  source ~/.bashrc

Certes, j'ai lancé ce script sur une machine virtuelle, donc nécessairement moins puissante 
que la machine physique hôte. Le temps est donc plus long que sur la machine physique.
Néanmoins, cela donne une idée du temps nécessaire.

  make                   1h 40mn
  make rakudo-test          20mn
  make rakudo-spectest   3h 10mn
  make install           1h

Notons qu'il y a des erreurs, mais que je suis passé outre. Et je pense que c'est justifié, au moins
dans le cas de "spectest". En effet, on sait que Rakudo Star n'implémente pas complètement la spécification
de Perl 6, ce qui se traduit par des erreurs dans "spectest". C'est normal.

=head3 Autres témoignages et remarques

On m'a fait remarquer que la compilation des sources nécessite beaucoup d'accès disque
et que l'utilisation d'une machine virtuelle pénalise ainsi la compilation. Donc les durées
que j'ai trouvées ne sont pas significatives. Néanmoins, cela montre que vous ne devez
pas vous attendre à ce que l'installation par compilation des sources soit réglée en 
cinq minutes sur votre machine.

Un participant des journées Perl a essayé de compiler Rakudo Star pendant la conférence.
Je ne sais pas s'il est passé par l'étape S<rakudo-spectest>, je sais par contre que l'étape
C<install> lui a pris beaucoup de temps.

Un autre participant, qui utilise Perl 6 depuis plusieurs années et, même, participe à son
développement, a dit qu'il compilait la version de développement de Rakudo Star chaque jour.
En fait, il semble que le temps énorme que prend la compilation est dû à l'installation de
modules Perl 5 nécessaires pour certaines étapes de cette compilation ou des tests. Donc, si
l'on compile Rakudo Star tous les matins, les modules utilitaires sont déjà installés et 
les étapes de la compilation prennent moins de temps que le premier jour.

Après les Journées Perl, j'ai réinitialisé ma machine xubuntu-16.10 64 bits en remplaçant par une distribution
xubuntu-18.04 64 bits. Il existe pour cette distribution des paquets NQP, Perl 6 et Rakudo.
Toutefois, pour avoir le cœur net, j'ai préféré installer Rakudo Star à partir des sources.
J'ai repris le même script que précédemment, auquel j'ai ajouté quelques appels à C<ifconfig>
pour avoir le nombre d'octets échangés avec Internet. De manière étonnante, l'installation
totale a duré moins de S<25 minutes !> Et à part le chargement de F<rakudo-star-2018.01.tar.gz>,
il n'y a eu quasiment aucun trafic réseau pendant l'installation, donc aucun module
Perl 5 n'a été installé.

En 2020,  j'ai retenté  l'expérience en compilant  Rakudo-Star 2019.03
sur une  machine virtuelle. J'ai  donc créé un machine  virtuelle avec
1024 Mo de mémoire vive et j'y ai installé xubuntu-19.10 (Eoan Ermine,
64 bits).  J'ai démarré le gestionnaire  de tâches de xfce,  puis j'ai
lancé  la  compilation de  Rakudo  Star.  Les problèmes  ont  commencé
lorsque  C<make>   affiche  C<stage   parse>.  Certes,   il  y   a  un
avertissement sur la possibilité que cette étape prenne du temps. Mais
20  minutes,  ça fait  vraiment  long.  Un  C<ps  -ef> montre  que  le
processus C<moarvm> correspondant  prend 1 ou 2 mn de  CPU, ce qui est
déjà lourd, mais cela ne justifie  pas le temps-horloge de 20 minutes.
Puis j'ai remarqué que le gestionnaire de tâches S<affichait :>

  Mémoire : 90 %    Fichier d'échange : 100 %

En regardant  plus attentivement, le  résultat de C<ps  -ef> affichait
que  le processus  de compilation  utilisait S<700  Mo> de  mémoire et
continuait à grossir.  La machine virtuelle disposant de S<1024 Mo> de
mémoire et d'un fichier F</swapfile>  de S<760 Mo>, elle était saturée
et passait  son temps à  sauvegarder et  charger des pages  de mémoire
virtuelle.

J'ai arrêté et  supprimé la machine virtuelle, puis j'en  ai créée une
nouvelle  avec   S<2048  Mo>   de  mémoire  vive.   L'installation  de
xubuntu-19.10 a créé  un F</swapfile> de S<760  Mo> comme précédemment
(je   n'ai  pas   cherché   comment  intervenir   dans  le   processus
d'installation  pour choisir  une autre  taille). Et  j'ai relancé  la
compilation de Rakudo-Star 2019.03. Cette fois-ci, le C<stage parse> a
pris un temps  raisonnable. L'étape C<make spectest> a  pris du temps,
tout en  montrant que cela progressait.  Sauf à la fin,  où il restait
deux  tests   qui  avaient   l'air  de  boucler,   F<s16-io/eof.t>  et
F<s32-io/out-buffering>. L'étape  C<make spectest>  étant facultative,
je me suis permis de faire un C<kill> sur ces deux processus et la fin
de  l'installation   s'est  déroulée  sans  problème   dans  un  temps
raisonnable.

=head2 Utilisation

=head3 Identifiants

Il paraît qu'avec  Perl 5, on pouvait utiliser  des lettres accentuées
dans les identifiants  de variable ou de fonction. Je  n'ai jamais osé
le faire avec Perl  5, mais je ne m'en suis pas privé  avec Perl 6. De
plus,  il  est  possible  d'utiliser   le  tiret  à  l'intérieur  d'un
identifiant à la place du souligné. Avec quelques limites, par exemple
le tiret ne peut pas être suivi  d'un chiffre, il faut que ce soit une
lettre.  On peut  écrire  C<$coef-a>,  mais on  ne  peut pas  utiliser
C<$coef-1>, il faut utiliser  C<$coef_1>, car C<$coef-1> représente la
valeur de C<$coef> diminuée de 1.

L'inconvénient, c'est que j'ai tendance à déclarer une variable C<$code-retour>
et à l'appeler ensuite C<$code_retour> (ou l'inverse). Je devrais utiliser
plus souvent l'auto-complétion d'Emacs (C<M-/>).

=head3 Indices négatifs

À un moment, dans un programme, il fallait que j'additionne ainsi
les éléments de deux tableaux (en syntaxe Perl 5)

  $t[0] = $a[0] + $b[4];
  $t[1] = $a[1] + $b[5];
  $t[2] = $a[2] + $b[0];
  $t[3] = $a[3] + $b[1];
  $t[4] = $a[4] + $b[2];
  $t[5] = $a[5] + $b[3];

Avec les index négatifs, on peut réécrire ces lignes ainsi en Perl 5 :

  $t[0] = $a[0] + $b[-2];
  $t[1] = $a[1] + $b[-1];
  $t[2] = $a[2] + $b[ 0];
  $t[3] = $a[3] + $b[ 1];
  $t[4] = $a[4] + $b[ 2];
  $t[5] = $a[5] + $b[ 3];

ou avec une boucle explicite

  for (0..5) {
    $t[$_] = $a[$_] + $b[$_ - 2];
  }

ou implicite

  @t = map { $a[$_] + $b[$_ - 2] } 0..5;

Mais en Perl 6, les indices négatifs sont interdits,
la syntaxe attendue est :

  @t[0] = @a[0] + @b[* - 2];
  @t[1] = @a[1] + @b[* - 1];
  @t[2] = @a[2] + @b[ 0];
  @t[3] = @a[3] + @b[ 1];
  @t[4] = @a[4] + @b[ 2];
  @t[5] = @a[5] + @b[ 3];

Donc impossible de faire cela en une seule boucle, il faut
en faire au moins deux. C'est nul, Perl 6...

... Puis j'ai pensé à APL. En APL, comment aurais-je fait ?
APL permet de faire cela sans même faire de boucle, en traitant
les vecteurs (nom indigène pour « tableaux ») dans leur totalité.
On commence par faire tourner le vecteur B sur lui-même pour
amener l'élément d'indice 4 (*) en première position.
Puis on l'additionne au vecteur A et on stocke le résultat
dans la variable T

(*) En fait, en APL, on a coutume de faire commencer les indices en 1.
Donc, c'est plutôt l'élément d'indice 5 que l'on place en position initiale.

  T ← A + ¯2 ⌽ B

Éh bien avec Perl 6, on peut faire l'équivalent :

  @t = @a «+» @b.rotate(-2);

APL, c'est génial, Perl 6 c'est génial !

=head3 Opérateurs Unicode

Un autre point que j'aime beaucoup dans APL, c'est que l'on peut
comparer des valeurs avec ≤ et ≥ (U+2264 et U+2265) au lieu de <= et >=. Et surtout,
on peut multiplier des nombres avec × (U+00D7) au lieu de cette abominable étoile
que tous les autres langages utilisent.
Éh bien on peut faire la même chose avec Perl 6 et utiliser ≤ ≥ et ×.
Lorsque j'ai fait un projet APL en 2014-2015, je m'étais écrit
une fonction C<apl-insert> en Emacs-Lisp pour insérer des caractères spéciaux dans
un source APL sous Emacs. Lorsque j'ai découvert la possibilité
d'utiliser ≤ ≥ et × en Perl 6, j'ai dupliqué ma fonction dans le
répertoire Perl 6 sans même purger les caractères APL qui ne
servent pas pour Perl 6 ni changer le nom de la fonction.

Remarque. Perl 5 connaissait déjà x (U+0078, la lettre "x") pour multiplier une chaîne
par un nombre ou une liste par un nombre. Mais hélas, la
multiplication numérique utilisait toujours l'étoile.

À ce propos, la répétition de chaîne et la répétition de liste
sont deux opérateurs différents en Perl 6, respectivement « x »
et « xx ». Évitez d'utiliser l'un pour l'autre comme je l'ai fait !

=head3 Un autre héritage d'APL

Remarque S<préliminaire :> j'aurais pu écrire ce paragraphe au moment de
la présentation en 2018 et je n'y ai pas pensé. Je me rattrape en
2020.

Dans les scripts utilisés pour jouer l'As des As, à un moment j'ai besoin
de calculer la fonction de répartition d'une loi de probabilité discrète
connaissant sa loi de répartition. Je ne vais pas vous faire un cours de 
probabilité, alors je vais utiliser un exemple similaire. En prenant une
année normale, sans 29 février, il s'agit de prendre un tableau contenant
le nombre de jours par mois et de calculer le tableau contenant pour chaque
mois le nombre de jours entre le 1er janvier et la fin du mois.
Le vecteur de départ est 

  31 28 31 30 31 30 31 31 30 31 30 31

en APL et

  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31

en Raku. Rappelons que les indices commencent habituellement à 1 en APL et qu'ils
commencent à 0 en Raku. Et appelons ces vecteurs C<NBJ> en APL et C<@nbj> en Raku.

Si c'est pour calculer le nombre de jours dans l'année, il suffit de faire 

  +/NBJ
  [+] @nbj

et l'on obtient le résultat 365. Mais pour le nombre de jours entre le 1er janvier
et la fin de chaque S<mois ?> En APL, c'est facile, il suffit de remplacer le slash
par un backslash

  +\NBJ

ce qui donne

  31 59 90 120 151 181 212 243 273 304 334 365

Dans mes livres francophones sur APL, cela s'appelle un S<« balayage »>.
Et en S<Raku ?>  Enhardi par les résultats des deux paragraphes précédents, je me
suis dit que si l'on peut faire un balayage en APL, on peut en faire un en Raku
également. Et si c'est le backslash qui fait le balayage en APL, pourquoi cela
ne serait pas le cas aussi pour S<Raku ?> J'ai donc essayé

  [\+] @nbj

et S<hourra !> j'ai obtenu le résultat attendu

  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,  365

=head3 Modification d'une sous-chaîne de caractères

Lorsque j'ai appris Perl 5 il y a un vingtaine d'années, une fonctionnalité
m'a fait comprendre que Perl 5 n'était pas simplement S<« un> langage de programmation
de S<plus »> mais bien un domaine dont l'exploration promettait d'être passionnante.
Cette fonctionnalité, c'est la possibilité d'utiliser C<substr> en partie gauche
d'une S<affectation :>

  substr($_,  0, 0) = "Larry";
  substr($_,  0, 1) = "Moe";
  substr($_, -1, 1) = "Curly";

dans I<Programming Perl> 2e édition pages 227 et 228.

Avec Perl 6, je n'ai pas pensé à vérifier que cela continuait à fonctionner, pour
moi c'était évident que Perl 6 reprendrait cette idée géniale.

Éh bien non, C<substr> ne peut pas être utilisé en partie gauche en Perl 6.
Le résultat est une erreur :

  Cannot modify an immutable Str

Je n'ai rien trouvé sur ce sujet dans les livres qui m'ont servi à apprendre Perl 6.
J'ai essayé avec L<la documentation en ligne de substr|https://docs.perl6.org/routine/substr>,
rien non plus sur ce sujet. J'ai essayé de regarder dans la 
L<documentation du type Str|https://docs.perl6.org/type/Str>
et pour cela il n'y avait pas de lien hypertexte depuis 
L<la documentation en ligne de substr|https://docs.perl6.org/routine/substr>,
j'ai dû passer par 
L<la liste des types standards|https://docs.perl6.org/type.html>.
Et sur la L<documentation du type Str|https://docs.perl6.org/type/Str>,
j'ai enfin trouvé ce que je cherchais, la 
L<fonction C<substr-rw>|https://docs.perl6.org/type/Str#method_substr-rw>.

=head3 Notation fonctionnelle

=for html
<img src='gof.png' width='45%' alt='Diagramme de Venn de la composition de deux fonctions' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>

Lorsque j'ai appris les relations et les fonctions en classe de 6e en mathématiques,
il y avait un point que je n'aimais pas et qui piégeait nombre de mes
camarades de classe, la notation pour la composition des fonctions.
Ainsi, « f suivie de g » se note « g rond f » et non pas « f rond g ».
La raison invoquée est qu'avec la notation fonctionnelle proposée par
Euler, on a :

     y = f(x)
     z = g(y)

donc

     z = g(f(x)) = gof (x)

J'ai beau être accoutumé à cette notation où les fonctions s'emboîtent
les unes dans les autres de façon que l'ordre chronologique se lit de droite
à gauche, je persiste à ne pas aimer. Et en plus, presque tous les
langages de programmation ont pris la suite du S<« traducteur> de S<formules »>
de Backus (FORTRAN) et reprennent allègrement cette monstruosité syntaxique.
Par exemple, vous prenez une valeur x, vous lui appliquez successivement
la fonction logarithme, la fonction cosinus, vous en prenez la valeur absolue
puis la racine carrée.
En dessinant un diagramme de Venn, cela donne :

=for html
<img src='hogof.png' width='45%' alt='Diagramme de Venn de la composition de quatre fonctions' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>

et en programmation, par exemple avec Perl 5 :

  $y = sqrt(abs(cos(log($x))))

Seul rayon de soleil dans cette grisaille, les calculatrices
HP mais aussi TI, qui permettent de coder dans l'ordre naturel :

  RCL 0
  LN
  COS
  ABS
  SQRT
  RTN

plus peut-être d'autres langages tels que Forth et Postscript que je n'ai jamais
appris, ou Smalltalk que j'ai à peine pratiqué.

Et maintenant, il y a aussi Perl 6 :

  $y = $x.log.cos.abs.sqrt;

=head3 Transformée schwartzienne

Si vous connaissez déjà la transformée schwartzienne, allez directement
L<au paragraphe suivant|"Transformation schwartzienne en Perl 6">.

=head4 Rappel de la Transformée schwartzienne en Perl 5

Supposons que je veuille trier une liste de chaînes de caractères en fonction
d'une date qui s'y trouve. La solution basique consiste à écrire :

  my @t = split /---\n/, <<'EOF';
  Georges Guynemer disparaît le 11 septembre 1917 aux environs de Poelcappelle.
  ---
  Le 21 avril 1918, Manfred von Richthofen est abattu à Vaux-sur-Somme.
  L'a-t-il été par le canadien Albert Roy Brown ou bien par les artilleurs de la 53e Batterie Australienne ?
  ---
  Première victoire aérienne à l'est : Petr Nicolaevitch Nesterov a volontairement percuté un Albatros autrichien le 8 septembre 1914.
  ---
  5 octobre 1914, première victoire en combat aérien par Frantz et Quenault sur le front ouest.
  ---
  Charles Nungesser, un temps surnommé « le Hussard de la Mors », est plus connu pour sa tentative de traversée
  de l'Atlantique le 8 mai 1927 et qui s'est terminée tragiquement que pour ses 45 victoires.
  ---
  La RAF a été créée le 1er avril 1918. Quel sens de l'humour !
  ---
  Sarajevo, 28 juin 1914 : un attentat qui a fait plus de 18 millions de morts et combien de blessés...
  ---
  11 novembre 1918, le cauchemar s'interrompt pour une vingtaine d'années.
  EOF

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;
  my $re = join '|', keys %mois;

  sub extr {
    my ($ch) = @_;
    if ($ch =~ /(\d{1,2})(?:er)?\s+($re)\s+(\d{4})/) {
      return $3 * 10000 + $mois{$2} * 100 + $1;
    }
    else {
      return 1e8;
    }
  }

  my @t1 = sort { extr($a) <=> extr($b) } @t;
  say join "\n", @t1;

En mettant un mouchard dans la fonction de comparaison, on constate qu'elle est appelée 15 fois,
donc la fonction C<extr> est appelée 30 fois, pour trier 8 paragraphes. L'idée est donc de 
remplacer 

  my @t1 = sort { extr($a) <=> extr($b) } @t;

par

  my @t0 = map  { [ $_, extr($_) ] } @t;
  my @t1 = sort { $a->[1] <=> $b->[1] } @t0;
  my @t2 = map  { $_->[0] } @t1;

Ainsi, la fonction d'extraction est appelée 8 fois au lieu de 30 et son résultat est conservé.
Mais habituellement, on écrit de façon plus concise et plus synthétique :

  my @t2 = map  { $_->[0] }
           sort { $a->[1] <=> $b->[1] }
           map  { [ $_, extr($_) ] } @t;

=head4 Transformation schwartzienne en Perl 6

Le problème avec cette expression concise,

  my @t2 = map  { $_->[0] }
           sort { $a->[1] <=> $b->[1] }
           map  { [ $_, extr($_) ] } @t;

c'est qu'il faut la lire de bas en haut ou de droite à gauche, dans
le sens inverse de la lecture normale (pour nous, habitués de l'alphabet
latin). C'est comme la composition des fonctions avec la notation
héritée d'Euler.

Avec Perl 6, nous avons l'opérateur I<feed>, ou C<< ==> >>, qui permet
de faire comme les I<pipes> Unix, travailler de gauche à droite et
de haut en bas. Ainsi, le programme devient :

  use v6;

  my @t = split "---\n", q:to/EOF/;
  Georges Guynemer disparaît le 11 septembre 1917 aux environs de Poelcappelle.
  ---
  Le 21 avril 1918, Manfred von Richthofen est abattu à Vaux-sur-Somme.
  L'a-t-il été par le canadien Albert Roy Brown ou bien par les artilleurs de la 53e Batterie Australienne ?
  ---
  Première victoire aérienne à l'est : Petr Nicolaevitch Nesterov a volontairement percuté un Albatros autrichien le 8 septembre 1914.
  ---
  5 octobre 1914, première victoire en combat aérien par Frantz et Quenault sur le front ouest.
  ---
  Charles Nungesser, un temps surnommé « le Hussard de la Mors », est plus connu pour sa tentative de traversée
  de l'Atlantique le 8 mai 1927 et qui s'est terminée tragiquement que pour ses 45 victoires.
  ---
  La RAF a été créée le 1er avril 1918. Quel sens de l'humour !
  ---
  Sarajevo, 28 juin 1914 : un attentat qui a fait plus de 18 millions de morts et combien de blessés...
  ---
  11 novembre 1918, le cauchemar s'interrompt pour une vingtaine d'années.
  EOF

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;

  my @mois = %mois.keys;

  sub extr(Str $ch) {
    if $ch ~~ /(\d+)'er'? \s+ (@mois) \s+ (\d+)/ {
      return $2 × 10000 + %mois{$1} × 100 + $0;
    }
    else {
      return 1e8;
    }
  }

  @t ==> map  { [ $_, extr($_) ] } \
     ==> sort { $^a[1] <=> $^b[1] } \
     ==> map  { $_[0] } \
     ==> my @t1;

  say join "\n", @t1;

Un point qui m'ennuie, c'est le fait d'être
obligé d'ajouter un backslash en fin de ligne pour indiquer que l'instruction
se poursuit à la ligne suivante. Comme l'a dit une personne dans la salle,
S<« C'est> un retour quarante ans en S<arrière. »>. Voir le 
L<point suivant|"Alignement vertical">.

=head4 Au-delà de la transformation schwartzienne

En fait, comme on m'a fait remarquer, la transformation schwartzienne perd pas mal
d'intérêt en Perl 6. Dans le cas particulier assez fréquent d'un tri avec une comparaison mono-critère,
vous pouvez remplacer la fonction de comparaison par la fonction d'extraction de 
ce critère unique. Cela S<donne :>

  @t ==> sort { extr($_) } \
     ==> my @t1;

Et à ce moment-là, Perl 6 mémorise en cache les valeurs des critères pour chaque élément à
trier. Le C<map> de stockage et le C<map> de déstockage ne sont donc plus utiles. Vous pouvez
faire le test en ajoutant un mouchard dans la fonction d'extraction (compteur ou impression
de message).

La transformation schwartzienne reste utile pour les tris multi-critères. En reprenant l'exemple
ci-dessus, on peut ne pas agglomérer le jour avec le mois et l'année et coder S<ainsi :>

  @t ==> map  { [ $_, annee($_), mois($_), jour($_) ] } \
     ==> sort { $^a[1] <=> $^b[1] || $^a[2] <=> $^b[2] || $^a[3] <=> $^b[3] } \
     ==> map  { $_[0] } \
     ==> my @t1;

Mais c'est plus laborieux et moins stylé.

=head3 Alignement vertical

Pour moi, l'alignement vertical dans le code est très important pour la compréhension
par un humain. Je ne parle pas simplement de l'indentation du premier caractère autre
que l'espace, je parle des éléments qui se répêtent d'une ligne à l'autre.
Par exemple, en Perl 5, je pourrais écrire :

  $longueur[$n] = $longueur[$n - 1] + $dx;
  $largeur [$n] = $largeur [$n - 1] + $dy;

En Perl 6, il est interdit d'écrire :

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur [$n] = @largeur [$n - 1] + $dy;

Car il ne doit pas y avoir d'espace entre le nom du tableau et le crochet ouvrant
qui donne l'indice. Il faudrait donc écrire ce code horrible :

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur[$n] = @largeur[$n - 1] + $dy;

Moi, je me suis résigné à écrire

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur[ $n] = @largeur[ $n - 1] + $dy;

Tous les éléments restent alignés verticalement, sauf les crochets ouvrants.

Il existe une fonctionnalité intéressante que vous avez aperçue au paragraphe sur 
la transformation schwartzienne, le I<unspace>. S'il y a un backslash suivi par
un ou plusieurs caractères blancs (espace, saut de ligne, etc), alors l'interpréteur
Perl 6 considère qu'il n'y a pas de blanc. Ainsi, les deux lignes suivantes
sont équivalentes :

  @longueur[$n]
  @longueur\       [$n]

Et dans le paragraphe sur la transformée schwartzienne, le backslash servait à
inhiber le saut de ligne qui suivait immédiatement, de façon que là où le lecteur
humain voit quatre lignes de longueur raisonnable, l'interpréteur voit une
instruction complète sur une ligne.

Le I<unspace> aurait-il pu me servir dans mon exemple longueur-largeur ? Non, car l'ajout
du backslash pour masque le blanc dans la ligne "largeur" aurait créé un décalage d'un caractère supplémentaire.
Il aurait donc fallu insérer un blanc dans la ligne "longueur", ce qui en cascade
aurait nécessité d'insérer un autre backslash dans la ligne "longueur". Cela aurait
donné au final :

  @longueur\ [$n] = @longueur\ [$n - 1] + $dx;
  @largeur\  [$n] = @largeur\  [$n - 1] + $dy;

On m'a donné d'autres suggestions pour traiter ce problème. L'une consiste à commettre
une faute d'orthographe et à écrire soit

  $longuer[$n] = $longuer[$n - 1] + $dx;
  $largeur[$n] = $largeur[$n - 1] + $dy;

soit 

  $longueur[$n] = $longueur[$n - 1] + $dx;
  $largeurr[$n] = $largeurr[$n - 1] + $dy;

Une autre suggestion consiste à installer un module qui change la syntaxe de Perl 6 pour admettre
des espaces là où la syntaxe standard les refuse. Hélas, je n'ai pas retenu le nom du module ni
celui de son auteur.

=head3 Les regex, anciennement expressions régulières

S<Note :> ce paragraphe a été remanié et allongé apès la lecture de
I<Parsing Perl 6 Regexes and Grammars> de Moritz Lenz, éditions Apress
et après le renommage de I<Perl 6> en I<Raku>.

À l'origine, aux premiers temps d'Unix et de C<grep>, voire avant, les expressions régulières
étaient juste des chaînes de caractères dans lesquelles quelques caractères
particuliers, peu nombreux, avaient le statut de S<« caractères> S<spéciaux »>,
tels l'accent circonflexe et le dollar servant de balises, le point servant
de caractère générique et l'étoile servant de quantificateur et tous les autres
caractères avaient leur valeur littérale. Ultérieurement, 
avec les versions évoluées de C<grep> et l'apparition de C<awk>, les caractères spéciaux
sont devenus de plus en plus nombreux, mais dans leur essence, les expressions régulières
étaient toujours des chaînes de caractères mêlant caractères littéraux et caractères spéciaux.

D'autres langages sont partis dans une autre direction, définissant les expressions
régulières comme une classe d'objets particulière, avec ses attributs et ses méthodes.

De temps en temps, un chercheur en mathématiques ou en informatique signale que telle 
ou telle construction intellectuelle est
L<S<« accidentellement> complète au sens de S<Turing »>|https://fr.wikipedia.org/wiki/Turing-complet#Exemples_en_dehors_des_langages_de_programmation>.
C'est le cas du Jeu de la Vie de John Conway, c'est le cas de
S<« Magic,> S<l'Assemblée »>, c'est le cas de Minecraft.
Et c'est peut-être le cas des expressions régulières de PCRE ou de Perl5,
ou d'autres langages de programmation (à vrai dire, je ne me suis pas plongé dans
la définition de S<« complet> au sens de S<Turing »>, donc ce que je viens de déclarer
au sujet des expressions régulières est peut-être faux).

Éh bien en Raku, les expressions régulières ne sont plus des données (chaînes ou objets),
ce sont des blocs de code. C'est écrit en bas de la page 5 du livre de Moritz Lentz.
D'ailleurs, il ne faut plus dire S<« expression> S<régulière »> ou I<regular expression>
mais tout simplement S<« regex »>. Une regex contient du code Raku avec une syntaxe
assez différente de la syntaxe impérative et procédurale habituelle, mais c'est du code
Raku, mêlant chaînes littérales, variables et opérateurs. C'est dit succintement page 5, c'est dit
de façon beaucoup plus détaillée dans la section 4.6, pages 42 à 46. Voici un exemple du
changement de mentalité à adopter avec Raku. Reprenons l'extraction d'une date 
figurant dans le paragraphe ci-dessus sur la transformée schwartzienne. En Perl 5,
l'extraction se fait ainsi

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;
  my $re = join '|', keys %mois;
  if ($ch =~ /(\d{1,2})(?:er)?\s+($re)\s+(\d{4})/) { ... }

La sous-expression servant à reconnaître un nom de mois est une variable scalaire contenant une bête
chaîne de caractères mêlant 11 occurrences du caractère spécial S<« C<|> »>
avec 12 chaînes littérales C<"janvier">, C<"février"> etc. En toute rigueur, j'aurais
dû ajouter des C<quotemeta>, mais comme les noms de mois sont purement alphabétiques,
ce n'était pas nécessaire dans cet exemple.

Ma première tentative en Raku, avant de lire le livre de Moritz Lentz et 
de comprendre quelle était la nature profonde des regex en Raku fut :

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;
  my $re = rx/janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre/;
  if $ch ~~ /(\d+)'er'? \s+ ($re) \s+ (\d+)/ { ... }

Et je me plaignais d'être obligé de faire du I<WET> (I<Write Everything Twice>)
en écrivant deux fois les noms de chaque mois au lieu de faire
du I<DRY> (I<Don't Repeat Yourself>) en les écrivant une seule fois.

La solution à laquelle je suis arrivé après avoir compris les regex de Raku,
c'est ceci :

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;
  my @mois = %mois.keys;
  if $ch ~~ /(\d+)'er'? \s+ (@mois) \s+ (\d+)/ { ... }

La regex utilisée fait référence à la variable C<@mois>. Mais là où Perl 5
aurait converti le tableau en chaîne de caractères pour l'insérer dans l'expression
régulière, la regex de Raku utilise ce tableau en tant que tableau, pour comparer
la chaîne traitée à chacun des éléments du tableau.


=head3 Typage des valeurs et des variables

Une grande nouveauté de Perl 6, c'est le fait que l'on peut associer
un type à une variable et que l'interpréteur fera les
vérifications de type associées. Seulement voilà, les contrôles sont parfois
un peu trop stricts. Soit le bout de code suivant

  class Exemple {
    has Num $.grandeur is rw;
  }
  my Exemple $donnée .= new;
  $donnée.grandeur = 1;

Résultat :

  Type check failed in assignment to $!grandeur; expected Num but got Int (1)
    in block <unit> at exemple1.p6 line 5

Cet exemple de code plante, parce que l'interpréteur attend un
C<(Num)> et qu'on lui donne un C<(Int)>. Non, il n'y a pas de conversion
implicite des entiers vers les flottants. Qu'à cela ne tienne,
il suffit d'écrire

  $donnée.grandeur = 1.0;

et le tour est joué ! Éh bien non, ça plante encore, cette fois-ci
parce que paraît-il on veut mettre un C<(Rat)>, c'est-à-dire un rationnel, dans un C<(Num)> !
Je m'en suis tiré d'abord avec une conversion explicite :

  $donnée.grandeur = 1.Num;

ce qui n'est pas élégant. Puis je me suis rappelé de certains
modules Perl 5 qui devaient renvoyer un résultat « vrai » en contexte booléen avec
une valeur donnant zéro en contexte numérique. Il y a les modules qui écrivent

  return 0 but true;

Astucieux, mais cela ne m'aide pas. Et il y a les autres qui écrivent

  return "0e0";

Beaucoup plus intéressant. J'ai donc écrit

  $donnée.grandeur = 1e0;

et c'est S<passé !>

=head3 Undef et (nil)

Un autre point qu'il faudra que je règle, c'est le typage des paramètres 
dans les fonctions. Si la déclaration de la fonction attribue
un type à un paramètre et qu'on appelle cette fonction avec C<undef>,
le programme plante parce que l'on fournit une valeur de type C<(Nil)>
à un paramètre de type C<(Num)> (par exemple). Dans ce cas, je me résigne
pour l'instant à ne pas spécifier de type.

=head3 Références

Lorsque j'ai lu les livres qui m'ont servi à apprendre le langage,
j'ai constaté certaines omissions (Désolé Laurent). L'omission la
plus flagrante pour moi est concerne les références. Même si l'on écrit

  @t[2]

au lieu de

  $t[2]

pour accéder à un élément de tableau, la notation

  $t[2]

existe toujours et concerne la variable $t qui contient une référence à une liste.
L'équivalent en Perl 5 est

  $t->[2]

Je ne me suis pas privé d'utiliser des références dans mes programmes, mais j'aurais
bien aimé avoir l'aval des gourous sur la question.

Et pour convertir une référence de liste en liste ? Impossible d'écrire :

  my $ref = <A B C D E F>;
  my @liste = $ref;

car cela crée une liste avec un seul élément, la référence à une liste.
Il faut en fait écrire :

  my $ref = <A B C D E F>;
  my @liste = $ref[*];

=head3 Opérateurs spécifiques

Une autre lacune, mais qui est restée pour l'instant théorique pour mes besoins, c'est
la possibilité de créer ses propres opérateurs. Comment définit-on la
priorité de ces opérateurs par rapport aux opérateurs S<traditionnels ?>

La réponse a été donnée pendant les Journées Perl. Elle consiste à utiliser
les S<« traits »> C<is tighter> ou C<is looser>. 
L<C'est marqué dans la doc|http://design.perl6.org/S06.html#Subroutine_traits>
à condition de savoir où chercher.

=head3 POD

Je ne me suis pas du tout intéressé à POD en version Perl 6. J'ai écrit la documentation de mes
programmes avec du POD tel que je le codais en Perl 5. La seule différence, 
c'est qu'il faut obligatoirement une balise C<=begin POD> et une balise C<=end POD>.
Et il n'y a pas de commande C<perl6doc>, à la place il faut utliser C<perl6>
avec l'option C<--doc>.

Néanmoins, si vous regardez les statistiques calculées par Github sur mon dépôt, 
vous verrez que parmi les langages utilisés, Perl 6 est très largement dominant.
Ce qui veut dire que le présent texte, entièrement écrit en POD version Perl 5,
n'a pas été pris en compte par les statistiques de Github, voire a été pris
en compte mais en tant que POD version Perl 6.

=head2 MongoDB

S<Avertissement :> hélas, je n'ai pas pris de notes lorsque j'ai installé le module MongoDB
pour Perl 6. J'expose ici mes souvenirs, qui ne sont pas fiables à S<100 %>.

D'autre part, ce que je raconte concerne l'installation que j'ai faite
le 17 mars 2018. J'ai pu constater que l'auteur du module MongoDB pour Perl 6
s'était remis au travail fin avril. Les bugs que je signale ont peut-être
disparu (et d'autres sont apparus...). Je n'ai pas voulu prendre le risque
de réinstaller le module pendant que je réalisais mes programmes et que je
rédigeais mon exposé. Je referai une nouvelle installation au moment où je
migrerai vers xubuntu 18.04.

=head3 Installation du 17 mars 2018

Tout d'abord, un problème qui n'a rien à voir avec Perl 6. Sur ma machine,
la version de MongoDB est la version 2.6, alors que le site web donne
la documentation d'une version 3.x. Par exemple, le site propose une commande
C<findAndUpdate>, qui n'existe pas sur ma machine. D'accord, il y a la possibilité d'accéder
à la doc 2.6 (ou par anticipation à la doc 4.0), mais je me suis contenté
d'avoir une doc légèrement déphasée plutôt que de cliquer sur de nombreux liens
pour trouver la doc parfaitement adaptée.

Avec l'installateur intégré C<zef> de Rakudo Star, l'installation du 
L<module MongoDB|https://modules.perl6.org/t/DATABASE>
se fait simplement par :

  zef install MongoDB

Et ça plante. Normal, il faut lire le F<README>, qui indique qu'il y a des problèmes
dans les scripts de tests et qu'il faut donc ne pas bloquer sur les erreurs obtenues.
Donc, faire :

  zef install --/test MongoDB

Et le module est installé ! Maintenant, il reste à écrire quelques programmes.
J'ai commencé par copier-coller l'exemple fourni dans la documentation
du programme. Mais ça plante ! D'après ce que je comprends des messages d'erreur,
cela plante à cause d'un sous-programme qui attend un paramètre C<(Str)> et qui
reçoit un C<(Int)>. Pour votre gouverne, il s'agit de trois lignes :

     debug-message("command done {$command.find-key(0)}");

Je vais donc dans le fichier désigné par le message d'erreur
(un fichier avec un nom horrible tiré d'un SHA1 ou d'un MD5) et je corrige en
supprimant les trois lignes en cause. Les messages de débug que je ne sais pas
interpréter, je me sens autorisé à les supprimer. Je reteste,
cela ne change rien. Je pense que le module figure en deux exemplaires : le fichier
source que j'ai modifié et un fichier de I<bytecode> que je n'ai pas vu.
Le I<bytecode> n'ayant pas changé, le bug est toujours là.

Je clone donc le
L<dépôt Git Hub|https://github.com/MARTIMM/mongo-perl6-driver/>, 
je supprime les trois messages de débug et je réinstalle par :

  zef install --/test .

(où « C<.> » désigne le répertoire courant, c'est à dire le dépôt Git local plutôt
que le dépôt hébergé par Github). Et C<zef> refuse car, me dit-il, le module est à jour.
En cherchant dans l'aide en ligne de C<zef>, je trouve une solution :

  zef install --force --/test .

Est-ce la bonne solution ? Je ne sais pas, mais au moins, ça fonctionne.
Le programme proposé dans la documentation du module fonctionne, à condition
d'enlever le C<findAndUpdate> qui n'existe pas en version 2.6.

Quand j'essaie de faire mes propres accès à MongoDB, j'ai de nouveau un 
problème, une histoire de promesse non tenue. Après moult tentatives, j'en viens
à la conclusion que dans un C<find>, il est indispensable de coder le paramètre :

      projection => ( _id => 0, )

c'est-à-dire, prendre tous les attributs du document, sauf l'attribut C<_id>.
Pourquoi cette exclusion ? Je ne sais pas. Tout ce que je sais, c'est que si l'on
exclut C<_id> ça fonctionne presque toujours (*), si l'on inclut implicitement C<_id> ça
ne fonctionne jamais. Donc maintenant, je code cette exclusion dans tous mes C<find>.

(*) Presque toujours, car il m'arrive de faire des erreurs sur d'autres points.

Tiens, j'ai mentionné S<« moult> S<tentatives »>. Le problème, c'est qu'à force de
zigzaguer dans les méandres de la syntaxe, j'ai effectué plusieurs tentatives identiques.
Pour éviter cette perte de temps, j'ai décidé au bout d'un certain temps d'écrire un livre de recettes, où je
mémorise chaque variante testée des accès à la base de données, avec les messages d'erreur
obtenus.

Par exemple, bien noter que l'instruction C<find> dans un programme Perl 6 ne reconnaîtra
pas les options C<sort>, C<limit> et C<find>. Et ce n'est pas un problème de version 2.6
contre 3.x, ces trois options sont mentionnées dans le livre O'Reilly de 2013 (page 68 si vous
voulez vérifier).

On trouve avec MongoDB une variante du problème évoqué dans le 
L<paragraphe sur le typage des données|"Typage des valeurs et des variables">.
MongoDB connaît les entiers C<(Int)> et les flottants C<(Num)>, mais pas les 
rationnels C<(Rat)>. Le message d'erreur n'est pas très S<clair :>

  2018-05-25 05:31:06.093687 [E]  1: localhost:27017: encode() on 0.5, error: Not yet implemented
  . At site#sources/9F1921D0AA42F2C1C0229F51082ED0A3E384968C (MongoDB::Wire):112
  2018-05-25 05:31:06.097117 [E]  1: No server reply on query. At site#sources/C727D6F914B4AE4082E938B9310DC8D2F4CD7B53 (MongoDB::Collection):101 in find()
  2018-05-25 05:31:06.098900 [E]  1: No cursor returned. At site#sources/BC4819BBBB818C799983157518CA75F0C1A6DFC7 (MongoDB::Database):73 in run-command()

Et si vous voulez le script minimal ayant donné cette erreur, le S<voici :>

  use v6;
  use BSON::Document;
  use MongoDB::Client;
  use MongoDB::Database;
  use MongoDB::Collection;

  my MongoDB::Client     $client  .= new(:uri('mongodb://'));
  my MongoDB::Database   $database = $client.database('exemple2');
  my MongoDB::Collection $coll     = $database.collection('exemple2');

  my BSON::Document $doc .= new: (
       numéro => 0.5,
       );
  my BSON::Document $req .= new: (
    insert => 'exemple2',
    documents => [ $doc ],
    );

  my BSON::Document $result = $database.run-command($req);
  #say "Création exemple2 ok : ", $result<ok>, " nb : ", $result<n>;

=head3 Installation du 21 juin 2018

Après avoir migré ma machine vers xubuntu-18.04 64 bits et MongoDB 3.6.3 et après avoir installé
Rakudo Star à partir des sources, j'ai voulu installer le module MongoDB pour
Perl 6. La commande

  zef install MongoDB

a planté parce que mon système ne contenait pas de F<libssl.so>. Il contient bien
une F<libssl3.so> ainsi qu'une F<libssl.so.1.1> et une F<libssl.so.1.0.0>, mais cela
ne semble pas avoir convenu aux tests de MongoDB. J'ai donc lancé la deuxième
variante de l'installation, celle qui ne tient pas compte des tests :

  zef install --/test MongoDB

Et l'installation s'est faite. J'ai lancé quelques programmes Perl 6 utilisant
MongoDB et ils ont fonctionné du premier coup. Un grand pas en avant entre
mars et juin 2018 !

Remarquez que je n'ai pas cherché à voir si le problème de 

      projection => ( _id => 0, )

ou le problème des C<(Rat)> conduisant au message

  2018-05-25 05:31:06.093687 [E]  1: localhost:27017: encode() on 0.5, error: Not yet implemented

existent encore.

=head2 Bailador

Au début, je n'avais pas l'intention de faire du web dynamique. Puis j'ai trouvé que
les fichiers HTML, avec les liens hypertextes qui conviennent, c'est plus facile à 
lire que le résultat d'une requête écrite dans un interpréteur de JavaScript.

Donc, j'ai installé Bailador. Que S<dire ?> J'ai installé le module, j'ai 
écrit un programme basé sur Bailador, et ça tourne. Je n'ai rien de croustillant 
à raconter.

Il faut dire que mon utilisation de Bailador est aussi rustique que l'utilisation 
de Dancer2 que j'ai présentée l'an dernier. Plus rustique même, puisque je n'utilise
pas de formulaires HTML. Si vous vous attendez à avoir autant
L<de modules pour Bailador|https://modules.perl6.org/t/WEB>
que ce dont vous disposez
L<pour Dancer2|https://metacpan.org/search?q=Dancer2>,
il va falloir attendre un peu (et, pourquoi pas, contribuer à l'effort).

Il y a juste un point à ajouter. Ce point n'est pas une conséquence de l'utilisation
de Bailador, mais je l'ai découvert parce que j'ai décidé d'utiliser Bailador.
Même si je ne connais rien à l'architecture MVC (I<Model, View, Controller>), j'ai
décidé de scinder mon programme Bailador en plusieurs fichiers. Le premier, 
F<site.p6> correspond, je pense, au Contrôleur. Dans un sous-répertoire,
j'ai F<lib/acces-mongodb.pm6>, correspondant au Modèle. Et j'ai d'autres
fichiers F<lib/site-coup.pm6>, F<lib/site-liste-parties.pm6> et F<lib/site-partie.pm6>
correspondant aux Vues. J'arrive à appeler les fonctions du Modèle F<lib/acces-mongodb.pm6>
depuis le Contrôleur F<site.p6>, mais pas depuis les Vues F<lib/site-xxx.pm6>.
J'ai encore quelques notions à apprendre sur les C<use> et les C<require> en Perl 6.

À compléter.

=head1 Conclusion

J'aime beaucoup Perl 6. J'avais quelques projets pour lesquels
j'envisageais d'utiliser APL, je pense que ces projets vont utiliser Perl 6
à la place. J'ai encore des lacunes à combler pour une bonne utilisation
de Perl 6, mais c'est juste une question de temps.

Quant au choix de l'As des As pour un projet dans le genre Google Alpha Go Zero,
il faut avoir à l'esprit que c'est un jeu beaucoup plus simple que le go
ou les échecs. Plus complexe que le tic-tac-toe certes, mais largement plus simple
de plusieurs ordres de grandeur que les deux jeux classiques. C'est pour cela
que j'ai pu créer un S<« Alpha> As des As S<Zéro »> sur un datacenter constitué
d'un seul PC de puissance moyenne.

=head1 LICENCE

Texte diffusé sous la licence CC-BY-NC-ND : Creative Commons avec clause de paternité, excluant l'utilisation commerciale et excluant la modification. 

Certaines illustrations sont diffusées avec une licence différente. Celle-ci est mentionnée à la suite de l'illustration.

