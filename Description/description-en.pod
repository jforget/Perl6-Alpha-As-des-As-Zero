-*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf-8

=head1 Introduction

This document is not an exact translation of F<description-fr.pod>.
The documents are about two years apart. In the interim Perl 6 has been renamed
Raku and I have learned much about this language. And I have removed
a few jokes which would puzzle the readers who does not share the same background
as me.

This project was what is called I<Conference-driven development>.
In 2018, I was looking for a project which could use Raku and MongoDB and
which could be interesting to the audience of the French Perl Workshop.
So I dug out from the depths of my memory an idea I had in the early 1980's
when I discovered Nova Games'
L<"Ace of Aces"|https://boardgamegeek.com/boardgame/798/ace-aces-handy-rotary-series>. 
Only later did I discover
that I could use Bailador, the Raku port of
L<Dancer2|http://perldancer.org/>
and that the conference
would be within a few weeks of the 100th anniversary of Richthofen's death
and of the 100th anniversary of the creation of the RAF. If you extend the
celebration window to a few months, it was also the 100th anniversary of
Guynemer's passing and of the 1918 armistice.

So, what is it about?
A few years ago, we learned that Google had experimented with I<supervised machine learning>
writing Google Alpha Go, a program to play Go. Then we learned about another
experiment, Google Alpha Go Zero and the chess equivalent Google
Alpha Chess Zero, which were I<unsupervised machine learning>
or I<machine self-learning>.

The software knows only the rules of the game and how to determine the result
of a game that has ended (win / draw / loss). It knows absolutely nothing about
the tactics or the strategy of the game. Then the software plays a huge 
number of games against itself, analyses the results and learns which are the
good moves and which are the bad moves.
 
This idea of machine self-learning did not appear in 2017 or 2018. I have read an article
in the 1970's describing what would be such a system for tic-tac-toe.
A few years later, when I discovered Nova Games' Ace of Aces, I thought that
this game, much more complicated than tic-tac-toe but hugely simpler than chess,
could be the ground for a similar self-learning system. For more than thirty years,
this idea was not implemented, until I decided to prepare this talk for FPW 2018.

=head2 A Sidenote about Hypertext Links Forerunners

When did we begin to number the pages of a book (or of a papyrus roll)?
When did we write for the first time "please see page #"?
When did we add an index of important words at the end of a book?
When did we write a book with an I<intensive> use of "see page #" references?

With the rise of natural sciences, especially botany, in the 18th century,
several books describing the flora of various regions were published. My father
showed me one of them, published in the 1950's and organised in a Q&A manner.

=for html
<blockquote>

In the leaves, how are the veins organized? If they are parallel, see page 17.
If they build a tree-like network, see page 33.

=for html
</blockquote>

And on pages 17 and 33, you would find other questions, other answers and other
target page numbers.

I have been told that in the 1960's, IBM published hardware maintenance manuals
based on a similar principle:

=for html
<blockquote>

If smoke pours out of the disk drive, see page 17. If it goes "crrr crrr crrr", see
page 33.

=for html
</blockquote>

The questions above are apocryphal, of course, but you can see the pattern.

In the 1970's, I watched on television a skit about "the shortest dictionary 
in the world". In dictionaries, what is space consuming is the definitions. So
by getting rid of the definitions, we can considerably reduce the size of the
dictionary. The skit performers gave a few examples. One I remember would give this in English:

  Clown: see circus
  Circus: see circle
  Circle: see club
  Club: see member
  Member: see parliament
  Parliament: see politician
  Politician: see clown

=head3 Warlock of the Firetop Mountain and its Legacy

In 1982, a new kind of book was published. The first title was
L<Warlock of the Firetop Mountain|http://fightingfantasy.wikia.com/wiki/The_Warlock_of_Firetop_Mountain_(book)>. 
In this kind of book, the player would choose how the story would develop. For example:

=for html
<blockquote>

Paragraph 1. You enter an inn. In the back of the main room, you see the innkeeper
cleaning a few glasses. On your left, in a dark corner, a man sits alone at a table, his
head covered by a black hood. On your right, you see (and hear) some boisterous 
mountain dwarves quaffing beer and laughing loudly. What do you do? You speak to
the innkeeper, go to paragraph 17. You sit down beside the hooded man, go to paragraph
33. You hail the dwarves with the words "Hello lawn ornaments!", go to paragraph 52.

=for html
</blockquote>

I had five of these books, in French. One is lost and I still have the four others.

=for HTML
<img src='Les_livres_dont_vous_etes_le_heros.jpg' alt="Four interactive books" width='85%' />

I<Personal picture. License is the same as for the text.>

=head1 Ace of Aces, the Game

In 1981, Alfred Leonardi filed a patent for a new type of game, which he had
developed with Douglas Kaufman. Instead of gathering two players in the same room around
the same game map and making them push cardboard markers, each player has a booklet
in which each page shows a plane seen from the cockpit of another plane.

=for HTML
<img src='pic1051809-l.jpg' alt="Example of game" width='85%' />

I<Picture taken by Chris Norwood and published on L<Boardgame Geek|https://boardgamegeek.com/image/1051809/ace-aces-handy-rotary-series?size=large>. 
License L<Creative Commons Attribution 3.0 Unported, CC BY 3.0|https://creativecommons.org/licenses/by/3.0/>.>

=head2 Rules Summary

The patent  gives an example  of a game  turn. The players  begin this
turn on page  1. In both booklets, the picture  shows that both planes
have the same  heading and that the  Dr.I is located at  the Camel's 4
o'clock, or conversely, the Camel is at the Dr.I's 10 o'clock.

=for HTML
<img src='Page-1-GB-All.png' alt="Page 1 in both booklets" width='100%' />

I<Pictures from patent USP 4,378,118, in public domain since 2001.>

At the bottom of each page, you notice a line of arrows and a line of numbers. 
Each number refers to a page of the booklet and each arrow is a graphical representation
of a maneuver the plane can execute. Each player chooses an arrow and gives the
corresponding page number to his opponent. For example, the German player
chooses the leftmost arrow and says:

-- I send you page 8.

At the same time, the British player chooses the arrow below "EF" in the "Cruising Left" part
and answers:

-- Go to page 48.

=for HTML
<img src='Manoeuvre-1-8-48.png' alt="Page 1, arrow pointing to page 8 and arrow pointing to page 48" />

I<Pictures from patent USP 4,378,118, in public domain since 2001.>

The German player opens his booklet page 48 and applies the same maneuver as before: same arrow,
different page number, 96. At the same time, the British player opens his booklet page 8,
spots the same maneuver and reads the page number. They obtain the same page number, 96.

=for HTML
<img src='Pages-48-8.png' alt="German booklet page 48 and British booklet page 8" />

I<Pictures from patent USP 4,378,118, in public domain since 2001.>

The final page for the game turn is page 96. As you can see, I<Ace of Aces> is not only a forerunner
of hypertext links, but it is also a forerunner for First Person Shooter games, 12 years or so
before Wolfenstein 3D and Doom.

=for HTML
<img src='Page-96-All-GB.png' alt="German booklet page 96 and British booklet page 96" />

I<Pictures from patent USP 4,378,118, in public domain since 2001.>

The fire / damage rules are very simple. Each plane starts with 12 hit points. Each time
you end your turn on a page where your plane receives bullets from the other guy, you lose
1, 2 or 4 hit points, depending on the specific page. Intermediate pages are not taken into
account. When your hit point total is zero or negative, your plane is shot down.

=head2 Explanation of the Mechanism

With this rule mechanism, the final pages are always the same for both players. 
Many newbie players are amazed by this, yet the explanation is simple.
Forget the skies above Poelcapelle or 
L<Vaux-sur-Somme|http://military.wikia.com/wiki/Manfred_von_Richthofen>,
and imagine you are in a big empty parking lot, with only a Mini Austin and 
a VW Beetle. At first, they set up in the following position (use the plain lines
and ignore the dotted lines):

=for html
<img src='Exp-1-A.png' alt='Start position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

This position corresponds to page 1 of both booklets.

Now, suppose the Beetle moves as shown below, while the Mini stays idle.

=for html
<img src='Exp-1-B.png' alt='Mini on its start position, Beetle on its end position' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

After this movement, we obtain the situation of page 8. And now, the Beetle stops
and the Mini starts moving.

=for html
<img src='Exp-1-C.png' alt='End position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

The end result is the position of page 96.

=for html
<img src='Exp-1-D.png' alt='End position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

Second step of the experiment. Both cars come back to the starting position
corresponding to page 1.

=for html
<img src='Exp-2-A.png' alt='Start position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

Now the Mini is the first to move, while the Beetle stays idle. So we obtain
the position like on page 48.

=for html
<img src='Exp-2-B.png' alt='Beetle on its start position, Mini on its end position' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

And when the Beetle moves, the end position is the position of page 96.

=for html
<img src='Exp-2-C.png' alt='End position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

Third step of the experiment. The cars come back to their page 1 position.
Now they move I<simultaneously>. As in both previous steps, the end position
is the page 96 position.

=for html
<img src='Exp-3-B.png' alt='End position for the cars' />

I<Personal picture. License is the same as for the text.>
I<Picture from patent USP 4,378,118, in public domain since 2001.>

So, there is no difference between moving simultaneously or moving sequentially
in this or that order. This is true both for cars in a parking lot and for planes
in the Picardy or Flanders sky.

=head3 Special Case, Page 223

=for html
<img src='page-223.jpeg' alt='Picture of page 223: no enemy plane, only clouds' />

I<Personal picture using a page from Handy Rotary, copyright © 1986 Nova Game Designs, Inc., artwork copyright © 1986 Emithill limited>

If you read some help files provided by
L<Boardgame Geek|https://www.boardgamegeek.com/boardgame/798/ace-aces-handy-rotary-series/files>,
you will understand that the game is based on a 37-hexagon grid and on a 6-heading orientation,
which produce 222 pages, for all relative positions of the planes, provided they are
with 3 hexagons of each other. But what happens if the distance is greater?
If, because of their maneuvers, the planes are separated by a distance greater than this
threshold, the booklets display a special page, Page 223 which show clouds behind which
the enemy plane has vanished. Even if the page shows clouds in front of the plane, the
enemy can have disappeared behind.

If only one player has an intermediate page 223, we use the intermediate page of the
other player to obtain the final page of the game turn. You can no longer check the consistency
of the final page as shown above. This situation arises, for example, when the planes are 
pursuing each other at a big distance. Let us suppose we are on page 180, where the Camel
is in the Dr.I's 11 1/2 o'clock and let us suppose the plane move forward at medium speed.
If we apply first the Camel's move, the contact is lost and the intermediate page is page 223,
where no maneuver is shown.

=for html
<img src='Page-223-a.png' alt='British movement ending at page 223' />

I<Personal picture. License is the same as for the text.>

On the other hand, if we apply first the Dr.I's move, the intermediate
page is page 60, where the Camel is in the Dr.I's 11 o'clock at medium
distance.

=for html
<img src='Page-223-b.png' alt='German movement from page 180 to page 60' />

I<Personal picture. License is the same as for the text.>

Then we apply the Camel's move and  we arrive on page 180. This number
cannot be cross-checked.

=for html
<img src='Page-223-c.png' alt='British movement from page 60 to page 180' />

I<Personal picture. License is the same as for the text.>

On the other hand, if both players' intermediate pages are page 223, or if the final page is page 223,
the planes have really broken contact. Each player chooses to stay and fight or to flee.
If both planes flee, the game ends in a draw. If both planes choose to stay, the fight begins again
on a neutral page as at the beginning of the game, but the difference is that the planes keep
their current level of damage. If only one plane decides to flee, its opponent obtains a half-victory.
But sometimes, it is better to flee and live and fight another day, than to press on the current
fight and lose and give a full victory to one's opponent.

=head3 Other Special Case, Tailing

When a plane is in the other plane's rear quadrant (4 o'clock to 8 o'clock) with a similar
heading, we consider that this plane is I<tailing> the other. It was the case on page 1
above (and also on pages 48 and 96, please notice the "T" under the page numbers in the
German booklet). I did not mention it for pedagogical reasons. When a plane is tailing another,
the simultaneous moves are no longer quite simultaneous. The sequence of play is now
the following:

=over 4

=item 1 The tailed plane chooses a maneuver.

=item 2 The player tells his opponent whether the chosen maneuver is
a leftward maneuver, a rightward maneuver or a forward maneuver. He does not
give the intermediate page number.

=item 3 The tailing player chooses a maneuver.

=item 4 Both players simultaneously announce their intermediate page numbers.

=item 5 Both players compute the final page.

=back

=head3 Successive Maneuvers

If you have read some help files provided by
L<Boardgamegeek|https://www.boardgamegeek.com/boardgame/798/ace-aces-handy-rotary-series/files>,
you may have noticed that in  the example above, when the German plane
goes from page 1 to page 8, its  move is a very low-speed move and the
plane stays  in its starting hex.  Doing this once is  fine, but doing
this  several times  in  a row,  this  is no  longer  flying, this  is
hovering. This is OK if you are  playing a hummingbird, a lark, a bee,
a drone or a gazelle (not
L<this kind of gazelle|https://simple.wikipedia.org/wiki/Gazelle>
but rather 
L<that kind of Gazelle|https://en.wikipedia.org/wiki/A%C3%A9rospatiale_Gazelle>)
but when you are  playing a Fokker Dr.I or a  Sopwith Camel, you cannot
hover. There is  an optional but very recommended  rule which prevents
planes from doing a slow speed  maneuver during turn I<n> if they have
already done a similar maneuver during turn I<n>-1.

In  the same  manner, the  rule deals  with acrobatics,  which can  be
executed during  turn I<n> only if  the aircraft did a  straight ahead
maneuver during turn I<n>-1.

=head3 Altitude

This is a game about planes, so we must deal with altitude, of course!
Well, no. For the basic rules, the game
L<just uses two dimensions|https://tvtropes.org/pmwiki/pmwiki.php/Main/TwoDSpace>.
There is only one instance when altitude is implied. There are six pages where both
aircraft are in the same hex. It is convenient to suppose that there are separated 
in altitude by a few meters. This is the players' opinion, the rules say nothing about
that.

There are advanced rules which require the players to log the altitude
at each  game turn. The  additional burden is  not worth it.  The only
optional  rule  which  is  worth  it  is  the  rule  about  successive
maneuvers.

=head3 A Few Remarks

During a game turn, you must keep in mind:

=over 4

=item 1 the initial page number,

=item 2 the maneuver you chose,

=item 3 the intermediate page number you gave to your opponent,

=item 4 the intermediate page number you received from your opponent,

=item 5 the final page number

=item 6 the number of remaining hit points,

=item 7 the type of maneuver (normal, straight ahead, acrobatic, slow speed) if using the rule on successive maneuvers.

=item 8 optionaly the number of remaining hit points for your opponent.

=back

According to some studies, the human short-term memory has room for 7 ± 2 pieces of data (except for
waiters in bars, who are way beyond this limit). Unless you are in the lower part of the
range, you can play I<Ace of Aces> without writing anything and without arraying markers on
any board. You can play anywhere: on the beach, beside the coffee machine, in a waiting
room, in the bus. And if your short-term memory is in the upper-range, you can even play
in the bus and not miss your stop.

=head2 Extensions

This game has two extensions, one with late war planes
(I<L<Powerhouse|https://boardgamegeek.com/boardgame/7104/ace-aces-powerhouse-series>>,
Spad XIII vs Fokker D.VII) the other with early war planes
(I<L<Flying Machines|https://boardgamegeek.com/boardgame/7103/ace-aces-flying-machines>>,
Airco DH2 vs. Fokker E.III). There is also a WWII variant
(I<L<Wingleader|https://boardgamegeek.com/boardgame/6504/ace-aces-wingleader>>, 
P-51 Mustang vs FW190), a cold war version 
(I<L<Jet Eagles|https://boardgamegeek.com/boardgame/1991/ace-aces-jet-eagles>>,
F-15 Eagle vs MiG-29 Fulcrum). There is even a Star Wars version,
I<L<Starfighter Battle Book|https://boardgamegeek.com/boardgame/3152/star-wars-starfighter-battle-book>>,
X-wing vs TIE-fighter, this last one published by West End Games.

All the bookets have the same positions at the same page numbers. For example, in every booklet,
page 96 is the page where the "bad guy" is tailing the "good guy" and shooting at him, at medium distance, with the
same heading. You can play any combination of a "good guy" booklet and a "bad guy" booklet,
even staging a fight between a X-Wing and a Fokker E.III! Or you can just match
a F-15 against a FW190, the closest way to reenact the
L<famous fight|https://www.youtube.com/watch?v=f3XNEWtJF0o>
between a pair of F-14's and a pair of A6M2 Zeros.

There are just a few problems. The distance scale is not the same from a game to the other: a few meters
for the WWI version, several hundred meters for the Cold War version. And the hit points are
much different. You will need a big dose of 
L<willing suspension of disbelief|http://tvtropes.org/pmwiki/pmwiki.php/Main/WillingSuspensionOfDisbelief>
to play such a game!

And you cannot set up a dogfight between two "good guys" (e.g. F-15 vs
P-51) or between two "bad guys" (e.g. Fokker Dr.I vs FW190).

A bit of caution about I<Wingleader>. There is 
L<another game|https://boardgamegeek.com/boardgame/160418/wing-leader-victories-1940-1942>
with a similar name. If you are interested by this game and if you want to buy it, be sure
it is the right game.

=for html
<img src='As-des-As-Wingleader-Jet-Eagles.png' alt="Ace of Aces, First World War, Second World War and Cold War" />

I<Personal pictures. License is the same as for the text.>

=for html
<img src='Jet-Eagles-96.png' alt="Page 96 for Jet Eagles, 'Red Force' booklet and 'Blue Force' booklet" />

I<Personal pictures using a page in the booklets from Jet Eagles, copyright © 1990 Nova Game Designs, Inc.>

All these variants propose advanced rules, e.g. altitude, 2-vs-2 or, in the case
of I<Jet Eagles>, radars and missiles. Unfortunately, these rules are incompatible with
the  7 ± 2 short-term memory capacity. Except for the already mentioned rule about compatibility between
two successive maneuvers, I do not plan to include these advanced rules in my programs.

There is also an extension 
I<L<Balloon Buster|https://boardgamegeek.com/boardgame/5736/ace-aces-balloon-buster>>
with a 2-vs-1 fight. The German player controls a rather passive
observation balloon and an anti-aircraft gun, while the British player
controls a plane.

Other similar extensions, but incompatible with the air combat series:
I<L<Shootout at the Saloon|https://boardgamegeek.com/boardgame/3089/bounty-hunter-shootout-saloon>>
translated in French as 
I<Le shérif et le hors-la-loi>,
I<L<Dragons Riders of Pern|https://boardgamegeek.com/boardgame/5735/dragonriders-pern-book-game>>
translated in French as 
I<les Maîtres des Dragons>
and a series I had not heard about before writing these explanations,
I<L<Lost Worlds|https://boardgamegeek.com/boardgame/3969/lost-worlds-adventure-set-i-ruins-ancients>>.

=for html
<img src='Le_sherif_et_le_hors-la-loi.png' alt="Shootout at the Saloon" />

I<Personal pictures using "Le Shérif et le Hors-la-loi", copyright © 1986 Gallimard,
French translation of "Shootout at the Saloon", Copyright © 1982 Nova Games Design Inc, copyright © 1986 Emithill Limited>

Since the patent is in the public domain, anyone can write and publish his own extension
to the Ace of Aces game. Here are a few examples:

=over 4

=item * Apache AH-64 vs Mi-24 Hind

=item * Quidditch: Griffindor vs Slytherin

=item * Superman vs Ironman

=item * Sparrowhawk vs hobbyist's drone

=back

Actually, I have chosen this last extension to add test data to my programs. I was
reluctant to use data from an existing game, because while the patent is expired, the
copyright is not.

=head1 Aces of Aces, the Programs

When I discovered the game, I thought that, actually, the game consists in mixing numbers
(page numbers) and symbols (maneuvers) to get other numbers. The role of the picture is 
just to add meaning for the benefit of the players and to help them choose the proper maneuver
symbol, provided the players know how the basics of plane flight, and provided they have 
some notions about the I<Dicta Boelke>, Sailor Malan's advices, "Boots" Blesse's 
I<No Guts, No Glory> and similar writings. But you can strip all this air combat decoration
and keep only the abstract mechanism, based on a finite state automaton with maybe a few
uses of a I<random> function. Hence the idea of a program playing the game without any knowledge
of air combat, but relying on a statistical analysis of previous games.

There are two parts in this project. First, preparation, to create booklets in electronic
format, by generating the files rather than typing them entirely from the paper version. Second, the game
itself, where cyber pilots fight against each other and learn from their mistakes.

=head2 Warning

When  I wrote  these programs,  I  used French  names for  everything:
programs, database  entities, variables, class names,  attribute names
and so  on. You may  have problems reading  the source files  and even
reading the  explanations. The only  exception is the  database, named
C<Ace_of_Aces>. Why? I do not remember.

=head2 Preparation

I have started with this part, of course. But I did not write the programs within the
Git repo, I wrote them in an external directory. Later, I cleaned them and I copied them
into the Git repo. You will not see my very first lines of Raku code.

Preparation itself is split into two steps. The first step consists in
establishing  the  relation between  page  numbers  and the  implicit
hexagon grid. For this, I have taken a booklet from an existing game and
I have copied enough pages to have at least one link to every one ot the 222 pages.

In the second step, for each aircraft, I write a JSON file describing the maneuvers
this plane can execute, I merge it with the database from the first step and
I generate a booklet, that is, the full list of transitions
(start page + maneuver) → end page. The program prints the booklet both in
JSON format and in HTML format.

You will learn more by reading the dedicated
L<documentation|https://github.com/jforget/Perl6-Alpha-As-des-As-Zero/blob/master/Preparation/description-en.pod>
for this step.

=head2 Game

The original game is meant for two human players with no umpire.
For the electronic players, I have prefered to use an umpire program, or
rather an umpire process, and two player processes. Both player processes use the
same Raku program, but the command line parameters are different.

To agree with the principles of Google Alpha Go Zero, the player program has absolutely
no knowledge of the flight mechanisms and of the air combat tactics. It just receives
from the umpire a list of possible maneuvers, chooses one of them and send it back to
the umpire.

The player program has two different modes. The first mode is the training mode, where
each maneuver is randomly chosen with equal probability. The second mode is the combat mode,
where the player program searches the database from similar situations encountered during 
previous games, evaluates which ones led to success and which ones led to failure, gives
different probabilities to these maneuvers and makes a random choice according to the probabilities.

Even in the combat mode, the maneuvers are chosen with a random function. So we prevent 
stereotypical plays, where each process would compute a minimax best solution and always obtain the
same choice in the same situation. The random choice gives a higher probability to the
best answer, but this does not prevent the program from choosing an unexpected maneuver
from time to time and take the enemy on his wrong foot.

The umpire program has a better knowledge of the flight mechanisms and the fire mechanisms, but
nothing about tactics. The umpire program reads the JSON files created by the preparation programs.
This allows it to know the relation (start page + maneuver) → end page. But the umpire program
does not know and does not care about the underlying hexagonal geometry.

=head3 Database

I have chosen L<MongoDB|https://www.mongodb.com/>
for the database. The reasons are not technical reasons (performance, for 
example), but the fact that I know data manipulation with SQL, but I am not familiar with
noSQL databases. The programs could be written with a SQL database, such as 
L<SQLite|https://sqlite.org/index.html>
or any other, but for me, it was less interesting.

During my FPW 2018 talk, someone remarked that MongoDB allows the storage of pictures,
which would be interesting for a game such as I<Ace of Aces>, which relies heavily
on pictures. Actually, this was not a criterion for my choice, I had no intention
to copy the plane pictures into the database.

The characteristics  of the various  aircraft are stored in  JSON text
files. At first,  it was the same for pilots,  which were described in
JSON text files. But I discovered  it was more convenient to store the
pilots in the database, the  gaming programs and the Bailador programs
would be  simpler. I  wrote a program  C<init-pilote> which  reads the
JSON  file describing  a pilot,  converts it  into a  Raku object  and
inserts  it  into the  C<Pilotes>  collection.  Similarly, I  wrote  a
program C<init-avion> (French for  "aircraft") which reads an aircraft
JSON file, converts  it and inserts it into  the C<Avions> collection.
For the training mode games, I need an anonymous pilot identified with
the same key  as the aircraft. So the  C<init-avion> program generates
this anonymous  pilot and inserts  it into the  C<Pilotes> collection.
The  JSON files  still  exist, but  they are  used  only for  database
initialization.

There  is a  problem when  reading back  the C<Avions>  and C<Pilotes>
documents into the  gaming programs and the Bailador  programs. On one
hand,  the  C<JSON::Class>  module generates  C<Avion>  and  C<Pilote>
objects from  a JSON  string, on  the other  hand the  MongoDB modules
generate C<BSON::Document>  objects, the data of which are accessed  with the same
syntax as hash  tables. There is no direct conversion  to a user class
such as  C<Avion> or C<Pilote>.  Should I write an  object constructor
which extracts  each value from  the C<BSON::Document> hash  table and
stores it into the corresponding attribute of the C<Pilote> / C<Avion>
object being created? Is there a  cleaner and simpler solution to this
dilemma?

In computer programming, there is a 
L<saying|https://stackoverflow.com/questions/288623/level-of-indirection-solves-every-problem>:
"Every problem can be solved by adding a level of indirection". I have
found  a similar  solution for  my current  problem. When  the program
creates  a C<Avions>  or  C<Pilotes> document  in  the database,  this
document contains  a C<json>  attribute to store  the raw  JSON string
used to  create the C<Avion>  or C<Pilote>  object. Then, in  the next
program,  when reading  the BSON  document,  I just  take the  C<json>
attribute  and I  build  the  C<Avion> or  C<Pilote>  object with  the
C<from-json>  method provided  by  C<JSON::Class>.  The only  required
entries  in  the  database   documents  are  C<identité>  (French  for
"identity") used as key and C<json> for the data payload. I have still
added some other entries to store some object attributes, because they
may be used for some database queries.

On  the other  hand, I  have not  defined classes  for games  and game
turns, I  use basic C<BSON::Document>  in the C<Parties>  and C<Coups>
collections respectively and  I use the hash table syntax  to read and
update data. Not very consistent, I agree.

=head3 Inter-Process Communication

Like I said above, there are three processes which send data to each other. Did I
use sockets? Message queues? No. I used a mechanism based on John le Carré spy novels,
the mailbox. The controlling officer writes his instructions to the spy on a microfilm
and inserts this microfilm into a agreed-upon discreet location: tree stump, crack between
two bricks in a wall, and the like. The spy comes a few hours later, takes the microfilm
and goes away. A few days later, after gathering the requested information, the spy 
delivers a new microfilm by inserting it in the same hidden place and the controlling
officer takes it in the same manner. This is the same with the umpire process and the
player processes. The umpire process writes a database record for each player. Then each
player process reads the record which applies to it, fills the missing data and rewrites
it. Then the umpire process reads the updated record.

Just as in John le Carré novels, if a process does not find the record it is waiting for,
it waits a few moments and it makes a new attempt. And as in John le Carré novels, 
after a number of failed attempts, the process considers something bad has happened 
on the other side and it stops all activities. The comparison ends there, because in
spy novels the spy is exfiltrated, while here the process executes a C<die>.

"With a hammer, everything looks like a nail". Indeed, but by doing so, I have only
one module to deal with, which reduces the number of standing issues (bugs and PEBCAK).

=head3 Umpire program: C<arbitre.p6>

The program begins,  as usual, with an initialization  step, where the
main variables are initialized. Nothing special to discuss.

Then you have  an event loop, which manages the  successive game turns
with the following steps:

=over 4

=item  1  Resolving  the  shooting  for the  previous  game  turn  and
computing the possible maneuver choices for the current turn.

=item 2 Writing these choices into the C<Coups> (game turn) collection for each player.

=item 3 Reading back the players' answers from the C<Coups> collection.

=item 4 Applying the transitions: initial page → intermediate page → final page.

=item 5 Checking whether a plane flees or not (or both planes).

=item 6 Dealing with the end of game (fleeing or destruction).

=back

=head4 Shooting

Fire combat for game turn I<n> is  actually computed in step 1 of turn
I<n>+1. Why? Because shooting involves  no choice from the players. It
is not necessary to execute a mailbox exchange just for the resolution
of any shooting.  We just wait for  the next turn and  the players are
warned they have lost some hit points  at the same time they are given
the  list of  maneuvers available  for the  new game  turn. It  may be
counter-intuitive, but I think the resulting programs are simpler.

Of course,  if step  1 computes that  a plane has  zero hit  points or
less, steps 2 to 5 are skipped  and we imediately deal with the end of
the game in step 6.

=head4 Tailing

For game turns where an aircraft is tailing another, steps 2 and 3 are
split in the following way:

=over 4

=item * 2A Writing into the C<Coups> (game turn) collection the choices for the tailed player.

=item * 3A Reading back the tailed player's answer from the C<Coups> collection.

=item  * 2B  Writing  into  the C<Coups>  (game  turn) collection  the
choices for  the tailing player, with  a G/A/D (left /  ahead / right)
indication relative to the tailed player's maneuver.

=item * 3B Reading back the tailing player's answer from the C<Coups> collection.

=back

When the umpire  program asks to the tailing plane  which maneuvers it
chooses,  it gives  a special  code to  the current  page number:  the
actual  number concatenated  with the  G/A/D code.  Going back  to the
example from  the patent,  the British  player is  page B<1>,  but the
German player is  page B<1G>, because the British player  has chosen a
leftward maneuver.  Pages 1G, 1A and  1D have exactly the  same set of
transitions  maneuver  →  final  page,   but  the  German  player  has
completely different sets of "previous situations" for page B<1G>, for
page B<1A> and for page B<1D>  from which to choose the next maneuver.
The player  program has no special  case for choosing a  maneuver when
tailing the enemy. The  price to pay is a that  the umpire program has
to  be careful  about  the page  number, which  is  no longer strictly
numeric and which might have a G/A/D letter or not.

=head4 List of Available Maneuvers

This step should not  require comments. But if you take  a look at the
conclusion paragraph  below, you will see  that the program has  a "no
quarters" option (I<à outrance>) for the training games. In this case,
the planes opt to  go on fighting, no matter how  many hit points they
have lost already. When this option  is on, the umpire program removes
all  maneuvers  which lead  to  an  intermediate  page 223.  The  only
exception is when I<all> maneuvers lead  to page 223, which can happen
with the  sparrowhawk. In these rare  cases, the list of  maneuvers is
not filtered.

On the other  hand, you cannot remove maneuvers which  would lead to a
I<final> page 223. So  the planes can end the game  turn on this page.
In this case, the umpire program gives  them a choice with 4 times the
attack option and only one fleeing option. So the fight most certainly
goes on. The probability is 16/25 instead of 1/4.

This filtering may  induce a cognitive bias in  the self-learning. But
this gives us richer training games  with many game turns, rather than
training games ending after a handful of turns.

=head4 End of Game

When the umpire  notices an end of game condition,  either a plane (or
both) having received enough hit points, or a plane (or both) fleeing,
the program  writes a last C<Coups>  record for each player,  with the
C<fini> ("ended") attribute set to C<1> and the C<résultat> ("result")
set to the  number of VP (+1,  -1, +1/2 or -1/2).  The pilot processes
will know that they must leave their event loop.

In  addition,  the umpire  program  writes  a  summary record  in  the
C<Parties> ("Games") collection.

=head3 Player program: C<joueur.p6>

The C<joueur.p6> program  is based on a loop,  reading each successive
game turn from the C<Coups> collection  and rewriting it to notify the
selected maneuver to the umpire.

Each player has two  attributes, I<psycho-rigidité> (mental stiffness)
and I<perspicacité> (perspicacity), used  to choose the next maneuver.
The I<psycho-rigidité>  is a  float greater  than or  equal to  1, the
I<perspicacité> is a float between 0 and 1.

Here are the successive steps for a game turn.

=head4 Extracting Similar Situations

The  program extracts  from  the C<Coups>  collection  all game  turns
similar to the current game turn, using the following criteria:

=over 4

=item 1 Same page.

=item 2 Previous game (according to the date-hour key).

=item 3 Same pilot or just any similar pilot.

=back

Let us look again at the criteria.

Same page: Remember that, for a tailing plane located on, say, page 1,
there are three different pages, page B<1G>, page B<1A> and page B<1D>
depending on the choice of the tailed plane for its next maneuver. The
situations from these pseudo-pages are not mixed together.

Previous game: We do not consider  the previous turns from the current
game, because we do not know the  final result yet. We do not consider
the next  games. It may seem  obvious, but the access  routine is also
used by  the website in the  page describing how the  player chose the
maneuver. This page may be accessed  several months after the game was
played, so we  need this criterion to reenact the  decision process as
it happened.

Same pilot  or similar. A  pilot acts  according to his  own knowledge
about  how his  plane  performs. But  he acts  also  according to  the
lessons he  received from his  instructors and  his peers. Let  us use
Guynemer on  a SPAD  XIII as  an example.  His instructors  were Jules
Védrines  and Paul  Tarascon. So  Guynemer will  use the  knowledge he
accumulated  himself, plus  the lessons  from the  training fights  by
anonymous pilots flying SPAD XIII's  and the knowledge that was taught
him by Védrines and Tarascon. In  other words, he will select C<Coups>
documents for  which the  C<identité> field  belongs to  the following
list (in Raku syntax):

  < Guynemer SPAD_XIII Vedrines Tarascon >

To be consistent, we must ensure that Védrines and Tarascon have flown
SPAD XIII  too. On  the other  hand, we  can imagine  a pilot  who has
learnt flying and fighting on a Fokker  E.III and who is assigned to a
Jasta flying Fokker D.VII's.

Another remark: the  C<ref> attribute exists in version V1,  but it is
not used. In other words, in version V1, Guynemer will use only:

  < Guynemer SPAD_XIII >

A last  remark: when extracting  the similar situations, a  pilot does
not care about the opponent. For example, when playing a Sopwith Camel
against a  Fokker Dr.I, the program  will extract any "Camel  vs Dr.I"
game  turn, but  also any  "Camel vs  Fokker E.III"  game turn  or any
"Camel vs Fokker D.VII" game turn.

=head4 Evaluating The Extracted Similar Situations

"Perspicacity"  means  "being  able  to see  through".  Through  what?
Through the haze of  passing time in our case. If a  game ends at turn
15, a perspicacious player will think  that the turn 10 maneuver could
have an effect on the final  result, while a short-sighted player will
attribute this  effect only to the  turn 14 maneuver, or  possibly the
turn 13 maneuver, but in this case only a very remote possibility.

How does  this translate in  program terms?  Here are a  few examples,
from which you will deduce the rule:

  Final result   final turn   current turn   perspicacity   score
      1 VP            15           10             0.1       0.00001
     -1 VP            15           10             0.1      -0.00001
      1 VP            15           14             0.1       0.1
      0.5 VP          15           14             0.1       0.05
      1 VP            15           10             0.5       0.03125
      1 VP            15           14             0.5       0.5
      1 VP            15           10             0.9       0.59049
     -1 VP            15           14             0.9      -0.9
     -0.5 VP          15           14             0.9      -0.45

=head4 Evaluating the Maneuvers

For  each possible  maneuver, the  program selects  all the  "previous
situations" that  were followed by  the maneuver being  examined. Then
the program adds  the scores of the corresponding  situations. It does
not compute the average value, it computes the total value. In theory,
that would give any value in the minus infinity to plus infinity span.

=head4 Choosing a Maneuver

This  is when  I<psycho-rigidité> (or  mental stiffness)  comes in.  A
stiff pilot  will nearly always  choose B<the> best maneuver  over any
other, while a more versatile pilot  will choose, from time to time, a
less  efficient maneuver  but which  will open  a new  set of  unusual
situations.

The   program  assigns   a   weight  to   each   maneuver,  by   using
I<psycho-rigidité>  and  raising  it  to the  power  of  the  maneuver
evaluation. Once all weights are  computed for all maneuvers, they are
normalized to obtain a probability distribution (P(A), P(B), P(C)...).
This  distribution is  then converted  into a  cumulative distribution
(P(A),   P(A+B),  P(A+B+C)...).   Lastly,  the   program  computes   a
pseudo-random number, compares it with the intervals of the cumulative
distribution and determines the chosen maneuver.

Here  is  an  example,  with  3   maneuvers  A,  B  and  C,  evaluated
respectively with  -2, 1  and 2.  With a really  stiff pilot  (10), we
have:

  maneuver  evaluation  weight   probability    cumulative
      A        -2         0.01      0.000091    0.000091
      B         1        10         0.090901    0.090992
      C         2       100         0.909008    1
    total               110.01      1.000000

If the random number is in  the 9.1e-5 to 0.090992 interval, we choose
maneuver B. If  the random number is greater than  0.090992, we choose
maneuver C.  And for  the very  unlikely case where  it is  lower than
9.1e-5, we choose maneuver A.

Same thing, with a more relaxed pilot (I<psycho-rigidité> 1.1):

  maneuver  evaluation  weight      probability  cumulative
      A        -2         0.826446   0.2634976   0.2634976
      B         1         1.1        0.35071543  0.61421303
      C         2         1.21       0.38578697  1
    total                 3,136446   1.00000000

As we  can see, the  probabilities are  around 1/3 for  each maneuver,
with still an advantage for maneuver C.

=head4 Training Games

If you lower the I<psycho-rigidité> to  1, you find that all available
maneuvers have the same probability,  no matter how many previous game
turns they  were used in and  which end result occurred  then. So, for
training games, I use an anonymous pilot with a mental stiffness of 1.
And when the program sees a mental  stiffness of 1, it does not bother
to extract  previous similar  situations, it does  not bother  to rate
them and to crunch numbers. The program just randomly picks a maneuver
among the available maneuvers.

=head4 End of game

When  the C<pilote.p6>  program  reads a  C<Coups>  document with  the
C<fini> attribute  set to 1, it  knows the game has  ended. It updates
all the  C<Coups> documents for the  current game to store  in each of
them the final result and the delay  between the game turn and the end
of game. This  will reduce the number of documents  to retrieve in the
next games.

=head3 C<site.p6> Program and its Associate Programs

C<site.p6>  and its  associate programs  C<lib/site-xxx.p6> are  basic
Bailador programs,  which read  a URL,  extract a  key from  this URL,
access the database  with this key, and display the  extracted data in
HTML.   Nothing  out   of  the   ordinary.  The   data  displayed   by
C<lib/site-coup.p6> may  be complicated, but they  mirror the decision
process  exposed  in  the   documentation  for  C<pilote.p6>,  so  the
documentation for C<pilote.p6> applies to C<lib/site-coup.p6> also.

=head2 A Few Questions

I have presented  this project during the French Perl  Workshop in May
2018 and  during a  meeting of  DC.pm in  March 2021.  Here are  a few
questions  I have  been  asked  and my  answers  (not necessarily  the
answers I gave directly).

Q. MongoDB is useful to store big  blobs of data, such as pictures. Do
you intend to store the pictures from the booklet?

A. No, for various reasons. First,  the copyright on the booklet still
holds,  even if  the  patent  is in  the  public  domain. Second,  the
experiment is about writing a program which knows nothing about flying
and about air  combat, but which does  statistics and number-crunching
to determine  the best move.  Using a picture would  sort-of discredit
the idea  of a  program knowing  nothing about  flying (a  rather weak
argument, I admit).  Third, I would need  to scan each one  of the 223
pages for  each booklet. A  lengthy endeavour,  for a (in  my opinion)
small benefit. And  for new craft or  creatures, such as a  drone or a
sparrowhawk, I would need to draw from scratch the opponents.

On the  other hand,  I think  that it  would be  nice if  the Bailador
webpages would draw  the arrows for each maneuver, in  addition to the
alphabetic code.

Q. But  you can see examples  on the web where  people have reproduced
the Ace of Aces pictures. Can't we do the same?

A. As  I said,  scanning the 223  pages of each  booklet is  a lengthy
process and  I do not  consider it  is worth the  time. If you  have a
different opinion, go  for it and scan the booklets  for personal use.
Showing 5 or  6 pictures from I<Ace  of Aces> on one's  webpage may be
considered fair  use, providing the  full set  of 223 pictures  may be
considered copyright infringement.

Q. How long is a Ace of Aces game?

A. Between two human players, it is difficult to say. When we play, we
do not  bother to count how  many game turns  we do. In terms  of real
life time, Board Game Geek gives  an average value of 20 minutes. That
would translate to about 100 game turns.

According to  the games in my  database, between two AI's  in training
mode, the durations varies between 4 and 83 game turns. In competitive
mode, it  varies between 13  and 131 turns.  But it is  the unbalanced
version, Sparrowhawk  vs Drone, so it  is not significant. I  have not
run enough Dr.I vs Camel games to give you significant values.

Q.  When an  AI  learns to  play  a game,  such as  chess  or go,  the
programmers uses some reference books  describing the game openings or
some common techniques and tactics. Is there such a thing for I<Ace of
Aces>?

A. No. Initializing  an AI with game openings was  how Google Alpha Go
was written. But its younger sibling Google Alpha Go Zero started from
a clean slate. I have done the same with I<As des As Zéro>.

Let us  leave aside my programs  and let us speak  about human newbies
learning the game. Are there any reference books for them to learn the
tricks  of  the  trade?  If  your consider  Chess  and  Go,  they  are
I<classic> games with a huge number of players, so there is room for a
big amount  of litterature on them.  You find very easily  hundreds of
books  and  magazines devoted  to  these  games.  On the  other  hand,
Mastermind and  Othello are  less famous, but  still classic.  You may
find  I<some>  litterature,  but  not   much  (I  have  a  book  about
Mastermind, my brother  has a book about Othello, but  that's all). On
the third  hand, for  Ace of  Aces, there  are not  enough experienced
players to write books and there  are not enough newbie players to buy
and read books. From another perspective, newbies interested in Ace of
Aces can  still read the  biographies of von  Richthofen, Rickenbacker
and Guynemer and others and study  the Dicta Boelke and the rules from
Sailor  Malan. And  the  lessons  learned would  be  useful for  other
dogfight wargames.

Q. The mechanism of Ace of Aces  looks like a Markov chain. Can we use
Markov chain methods to play the game?

A. I know the concept of Markov chains, but I have never used them. So
I cannot  give a  substantiated opinion.  Yes, the  game looks  like a
Markov chain. But  there is a combinatory problem in  the game. In the
basic "Handy Rotary" version, both planes have more than 20 maneuvers.
In the  WWII version  "Wingleader", the planes  have 13  maneuvers. So
there  are  169  possible  outcomes from  a  starting  situation  with
Wingleader, there are more than 400 with Handy Rotary.

Q. Does the player program take in account its opponent's preferences
and idiosyncrasies?

A. No, the  player program does not  examine if there is  a pattern in
its opponent's answer,  caused by some preference  or idiosyncrasy. It
just extract all relevant game  turns, make statistics, crunch numbers
and  build  probabilities. Yet,  as  I  have  mentioned in  L<List  of
Available  Maneuvers> paragraph,  the  I<à outrance>  option may  have
introduced a bias for both the player and its opponent.

Q. Is it possible to play a game between a human and an AI?

A. Yes,  it would  be rather  simple to write  a player  program which
interacts with  a human and relays  his choice to the  umpire process,
instead of a  program gathering statistics and  crunching numbers. One
problem  is the  time scale.  I have  included failsafe  tests
in the programs. It the umpire process does not receive an answer from
either  player  process  for  about 50  seconds,  the  umpire  process
considers that  the player  process has crashed,  aborted or  ended in
some fashion  and it decides to  stop. Same thing if  a player process
does not  receive an answer from  the umpire process. In  theory, this
50-second time-out  should be  enough for  a human  player. This  is a
simulation of  a fast-paced  aerial combat, so  the player  should not
ponder for  5 minutes what would  be the best maneuver.  But actually,
there are  several reasons why  a human  player would give  his answer
after more  that 50  seconds: the  phone rings,  or the  doorbell, the
microwave oven  beeps because the  pizza is  warm, the baby  starts to
cry, his two older siblings start  a row, the dog looks imploringly at
you with the leash in its mouth,
L<etc|https://www.imdb.com/title/tt0080455/quotes?item=qt0320024>.
A human opponent  would easily understand that real  life interfers, a
computer opponent  would still  enforce the 50-second  timeout without
second thoughts.

Lastly, a question more about Raku than about Ace of Aces.

Q. What  was the most helpful  feature of Raku when  developing Ace of
Aces?

A. On  3rd March,  I answered  the wrong  question. The  most pleasing
feature (not the most helpful) is  that Raku uses some features I have
learned long ago  in APL, especially the operations  on lists (vectors
in  APL  parlance) as  a  whole  instead  of processing  each  element
separately in a loop.

L<The Most Useful Feature Of  Raku> is actually the commonalities with
Perl. Much of what you write in Raku is very similar to what you would
have  written in  Perl: curly  braces, semi-colons,  C<my> and  C<sub>
operators, etc.

=head2 Todo List And Vaporware

Here is  a list of  possible improvements for  this project. I  do not
necessarily  intend to  achieve all  of them.  That is  why the  title
mentions  "vaporware". If  you  are interested  in implementing  these
points, you can still get in touch with me.

=head3 Coding Standards

The biggest mistake I did in this project was thinking that I would be
the only one to read and write code. So I used French names for nearly
everything:  database  keys,  variable  names,  function  names,  code
comments, user documentation and contents  of the webpages. The result
is  that  except  for  French-speaking programmers,  my  programs  are
completely obscure.

So I will rewrite at least  the game part using English names, English
comments,  English  whatever.  And  the  webpage  generation  will  be
multilingual,  generating  English-speaking pages  or  French-speaking
pages depending  on the user's  choice. The preparation step  might be
translated in English, but not soon.

=head3 Graphics, Part 1

Until now,  I was perfectly OK  with displaying the maneuvers  as mere
alphabetic codes. Now, I think it would be better if the arrow symbols
could be displayed together with the alpha maneuver code.

=head3 Graphics, Part 2

As already  mentioned above,  some people  think it  would be  nice to
display the full images from the booklets.  I do not plan to do it for
myself, but if you are interested in this, you can fork my Github repo
and add this functionality.

=head3 Website

In  addition  to  multi-linguism,   the  website  should  be  somewhat
improved: more queries, more options...

=head3 Training Mode

When starting a game and when resuming a game after visiting page 223,
it is customary to use a neutral page, that is, page 170. So this page
is over-represented in  the database. While the use of  a neutral page
is justified  in competitive games,  it is not important  for training
games.  So  the  umpire   program  should  accept  a  C<starting-page>
parameter to expand the coverage of the database.

=head3 Human-vs-AI Mode

There should be a human player  program, which would prompt for a play
and read the user's answer  from the command-line. As explained above,
the  programs should  be adapted  to switch  to a  mode with  a longer
timeout duration.

Or instead of the command line, the human-player program could display
a simple web-form and read the player's answer with this web-form.

=head3 Compatibility of Maneuvers

Enforce the rule about  the compatibility between successive maneuvers
to prevent, for example, helicopter-like hovering. The problem is that
this would obsolete all previous games in the database.

=head3 Other AI Technologies

Instead of  a pure number-crunching  AI, program a  neural-network AI.
The problem is that I do  not know anything about neural networks. But
if someone else is interested, fine by me.

=head2 Conclusion: Lessons Learned with Ace of Aces

A point  which surprised me, although  I could have guessed  it before
discovering it, is  the answer to page 223 when  fighting. The purpose
of the flight  (from the verb "to  flee", not "to fly") is  to allow a
damaged plane to survive  and to grant no more than  one half point to
the opponent, instead  of staying involved in a bad  fight and, in the
end, grant a  full victory point to the enemy.  Yet, the pilots nearly
always choose to stay and fight, even in desperate situations.

What happens  in the programs,  is that  choosing the flight  gives an
always negative result: -0.5 VP is the  enemy stays, 0 VP if the enemy
also chooses to flee, on average -0.25 VP. On the other hand, choosing to
go on fighting gives more or  less similar probabilities for a victory
and for a defeat. On average, the win is 0 VP. There is no distinction
between  desperate  cases where  the  aircraft  has  just one  or  two
remaining hit points and the comfortable situations where there are 11
hit points remaining. So the cyber pilots prefer to stay.

What  should be  done is  to filter  the results  from previous  games
according to the current level of damages. If a pilot is page 223 with
only  2 hit  points  remaining from  the initial  12,  the search  for
previous games will give more importance to game turns where the pilot
had 1, 2 or  3 hit points remaining than to game turns  where he had 8
hit points or more.  With this method, may be the  pilots will flee in
this situation.

On the other hand, in training mode, fleeing is not useful, because it
shortens the  training session and it  reduces the amount of  data for
future fights.  For this reason, I  have created a I<à  outrance> ("no
quarters") mode, where  choosing the attack has  a greater probability
than choosing to flee.

=head1 Annex: In Retrospect, My First Steps In Raku

=head2 Documentation

To learn a  new skill, I prefer  reading a book printed  on paper than
browsing tutorials on the web. The books I used for this project are:

=over 4

=item * 

L<Think Perl 6|https://greenteapress.com/wp/think-perl-6/>
by Laurent Rosenfeld (renamed
L<Think Raku|https://github.com/LaurentRosenfeld/think_raku>),

=item *

L<Perl 6 Deep Dive|https://www.packtpub.com/product/perl-6-deep-dive/9781787282049>, 
which I had  received and which I  began to read just a  few days before
writing my first lines of code for this project,

=item *

L<MongoDB, the Definitive Guide|https://www.eyrolles.com/Informatique/Livre/mongodb-the-definitive-guide-9781449381561/>
with no line of Raku code (even of Perl code), but very useful for this project.

=back

After the first version of this project, I have also read and appreciated:

=over 4

=item *

L<Learning Perl 6|https://www.oreilly.com/library/view/learning-perl-6/9781491977675/>
similarly renamed L<Learning Raku|https://www.learningraku.com/>,
by C<brian d foy>,

=item *

L<Parsing with Perl 6 Regexes and Grammars|https://www.apress.com/gp/book/9781484232279>
by Moritz Lenz, about L<Regexes, formerly Regular Expressions>.

=back

For specific requests (not for a wide-range learning), I still
use websites, mainly the
L<documentation of standard types|https://docs.raku.org/type.html>
and the L<list of modules|https://modules.raku.org/>.

=head2 Installation

There are four methods to install Raku on a Linux computer:

=over 4

=item 1

Installing the F<.rpm> or F<.deb> package provided by your distribution.

=item 2

Installing the F<.rpm> or F<.deb> package provided by a L<contributor|https://github.com/nxadm>
in a L<Github repository|https://github.com/nxadm/rakudo-pkg/releases>

=item 3

Downloading a Docker image, as suggested by Moritz Lenz in his book I<Perl 6 Fundamentals>.

=item 4

Compiling the sources.

=back

In my case, the second method did  not apply, there was no package for
xubuntu 16.10.  And the  first method was  giving obsolete  (for 2018)
versions. My various hardware and virtual computers at this time were:

  hardware    xubuntu-12.04   32 bits  rakudo 2011.07
  virtual     xubuntu-14.10   32 bits  rakudo 2013.12
  virtual     lubuntu-15.10   32 bits  rakudo 2014.07
  hardware    xubuntu-16.10   64 bits  rakudo 2016.06
  virtual     Mageia-5        32 bits  not found

About Docker: first Docker would need  to be installed on my computer,
second I should know Docker and  be comfortable with it. Docker is not
installed on my xubuntu-16.10  machine, the xubuntu-16.10 repositories
are no  longer available,  I do not  know to use  Docker and  for what
little I know about Docker, I guess I will not be comfortable with it.

So I compiled Rakudo Star 2018.01 from the sources. The first time, it
took a long time, several hours. The  second time, I wrote a script so
I would not need to type the successive commands and the compile would
run unattended. The script would also  display the date and time after
each step. Here it is:

  #!/bin/sh
  # -*- encoding: utf-8; indent-tabs-mode: nil -*-

  interlude() {
    echo
    echo
    date +'%Y-%m-%d %H:%M:%S'
    echo
    echo
  }

  mkdir ~/rakudo && cd $_
  wget https://rakudo.perl6.org/downloads/star/rakudo-star-2018.01.tar.gz
  interlude
  tar -xvzf rakudo-star-2018.01.tar.gz
  interlude
  cd rakudo-star-2018.01/
  interlude
  perl Configure.pl --backend=moar --gen-moar
  interlude
  make
  interlude
  # If you wish, you can run the tests
  # Depending on your machine, they could take over half an hour to run
  make rakudo-test
  interlude
  make rakudo-spectest
  interlude
  make install
  interlude
  echo "export PATH=$(pwd)/install/bin/:$(pwd)/install/share/perl6/site/bin:\$PATH" >> ~/.bashrc
  source ~/.bashrc

Of  course, the  script has  changed a  little, with  the renaming  to
"Raku"   and    the   obvious   change   of    version   number.   See
L<https://rakudo.org/downloads/rakudo/source>, the "Build" paragraph.

Since the  script has run on  a virtual machine, which  is necessarily
less powerful  than the  host computer,  the time  was longer  than it
would have  been on  my physical  machine. Yet,  this would  give some
insights.

  make                   1h 40mn
  make rakudo-test          20mn
  make rakudo-spectest   3h 10mn
  make install           1h

In addition, there were some errors  in the "spectest" step, but I did
not mind, because Rakudo Star is  a work in progress, which means that
not  every  feature  is  implemented.  Yet,  even  if  we  remove  the
"spectest"  part, which  is optional,  the compile  still takes  about
three hours!

In 2020, I renewed the experiment, by compiling Rakudo-Star 2019.03 on
a virtual machine.  The VM was running two apps:  the task manager and
the xterm CLI windows where I  launched the compilation script. At one
time, I noticed that the  task manager was displaying (translated from
French):

  Memory: 90 %     Swap file: 100 %

So I  understood why the compilation  was taking so long  and why even
the mouse  was unresponsive: the  VM's VM  was thrashing! I  mean, the
virtual machine's virtual memory was thrashing.

The  VM was  configured with  a 1024  MB  RAM. I  shut it  down and  I
discarded it, then I created a new  VM with a 2048 MB RAM, I installed
xubuntu-19.10 (Eoan Ermine) and xfce,  and I ran again the compilation
script. The duration  was still a long one, but  this time measured in
minutes instead of hours. And there  were two test scripts which would
not stop,  F<16-io/eof.t> and F<32-io/out-buffering>. For  the reasons
mentioned above, I killed both test processes. The compilation process
ended a few minutes later with no other incident.

So, if you want to compile Raku  (or Rakudo Star) from the sources, be
sure your  computer has  at least 2  GB's worth of  RAM. And  skip the
"spectest" step.

=head2 Usage

=head3 The Most Useful Feature Of Raku

It took me much time to be  aware of this simple fact: the most useful
feature of  Raku is that  it shares  many features with  Perl: syntax,
semantics, even the programmers' community.

An example about the common syntax: take this program.

  sub fact {
    my ($n) = @_;
    if ($n <= 1) {
      return 1;
    }
    else {
      return $n * fact($n - 1);
    }
  }

  print join ' ', 5, fact(5), "\n";
  print join ' ', 8, fact(8), "\n";
  print join ' ', 12, fact(12), "\n";

It is valid both for Perl and Raku  and it does the same thing in both
languages. Or course,  some purists will say that, as  a Raku program,
this is programmed with bad style. But for a seasoned Perl programmer,
writing  basic  Raku code  is  easy.  The seasoned  Perl  programmer's
"baby-Raku" is much richer than the total newbie's "baby-Raku".

If you  want to know  what a  more idiomatic factorial  function would
look like, here is what it would look like:

  sub fact(Int $n --> Int) {
    if $n ≤ 1 {
      return 1;
    }
    else {
      return $n × fact($n - 1);
    }
  }

Another more elaborated and yet shorter example:

  multi sub fact(Int $n where 0 ≤ $n ≤ 1 --> Int) {
    return 1;
  }
  multi sub fact(Int $n where $n > 1 --> Int) {
    return $n × fact($n - 1);
  }

The three variants are not functionally equivalent. All three give the
proper result  when called with  a valid input.  But if you  call them
with a number  with a fractional part, the  idiomatic versions trigger
an error, while the Perl version gives  you a dummy result. And if you
call  these  functions  with  a negative  integer,  the  last  variant
triggers an error, the two others give a 1.

Of course, in the following, I  will give the differences between Raku
and Perl, because  if I limit myself to the  common features, you will
not learn much.

=head3 Identifiers

It  seems that  with some  recent versions  of Perl,  you can  include
accents in the variable names and the function names. I never dared do
this in Perl, but in Raku it is has become customary. In the same way,
you can  use the dash or  hyphen inside an identifier  where you would
use underscore in  Perl. There are a few conditions,  though. The char
following the hyphen  must be a letter. You can  write C<$coef-a>, but
not C<$coef-1>,  which would be  interpreted as a  subtraction between
C<$coef> and C<1>.

The downside  of this is  that sometimes, I declare  a C<$return-code>
variable and  then I use  C<$return_code> (or the opposite).  I should
use Emacs' auto-completion  more often. Another downside  is that with
vowels properly accented, I feel  more inclined to use French variable
names than in Perl and for you, reading my code is more difficult.

Actually, even English speakers can benefit of the new syntax for variable
names. Take for example my first Raku module, the
L<French Revolutionary calendar module|https://modules.raku.org/dist/Date::Calendar::FrenchRevolutionary:cpan:JFORGET>
first released in 2019. In the English speaking examples, I have used
variable names such as C<$Bonaparte's-coup> and
C<$Robespierre's-downfall>.

=head3 Negative Indices in Arrays

At one time, I had to add together the elements of two arrays, in this
fashion (Perl syntax):

  $t[0] = $a[0] + $b[4];
  $t[1] = $a[1] + $b[5];
  $t[2] = $a[2] + $b[0];
  $t[3] = $a[3] + $b[1];
  $t[4] = $a[4] + $b[2];
  $t[5] = $a[5] + $b[3];

With negative indices, these lines can be rewritten this way in Perl:

  $t[0] = $a[0] + $b[-2];
  $t[1] = $a[1] + $b[-1];
  $t[2] = $a[2] + $b[ 0];
  $t[3] = $a[3] + $b[ 1];
  $t[4] = $a[4] + $b[ 2];
  $t[5] = $a[5] + $b[ 3];

You can compact this with an explicit loop:

  for (0..5) {
    $t[$_] = $a[$_] + $b[$_ - 2];
  }

or an implicit one:

  @t = map { $a[$_] + $b[$_ - 2] } 0..5;

But in Raku,  you cannot use negative indices. The proper Raku syntax is:

  @t[0] = @a[0] + @b[* - 2];
  @t[1] = @a[1] + @b[* - 1];
  @t[2] = @a[2] + @b[ 0];
  @t[3] = @a[3] + @b[ 1];
  @t[4] = @a[4] + @b[ 2];
  @t[5] = @a[5] + @b[ 3];

So it is impossible to do this in a single loop in Raku. Raku sucks...

...Then  I remembered  APL. How  would I  have done  this in  APL? APL
allows  you  to  do  this  kind of  computation  without  a  loop,  by
processing vectors (APL-parlance  for "arrays") as a  whole. First you
rotate vector  B to bring  the element with index  4 (*) in  the first
position.  Then you  add this  vector to  vector A  and you  store the
result in vector T.

(*) Actually, in  APL, it is customary  to begin with index  1. So, in
this case, you bring the element with index 5 in the first position.

So you write:

  T ← A + ¯2 ⌽ B

You can do the same in Raku:

  @t = @a «+» @b.rotate(-2);

The syntax is a bit less elegant, but the semantics are the same.

APL rules! Raku rules!

=head3 Unicode Operators

Another point I  like in APL is  the fact that you  can compare values
with ≤ and  ≥ (U+2264 and U+2265)  instead of <= and  >=. Even better,
you can multiply number with ×  (U+00D7) instead of this horrible star
that all other programming languages use.  We can do the same in Raku,
using ≤ ≥ and ×. When I worked  on an APL project in 2014--2015, I had
written an  Emacs-Lisp function  C<apl-insert> which would  insert APL
special chars into the source code. When  I discovered I could use ≤ ≥
and × in Raku,  I copied the Emacs-Lisp file into  the directory of my
Raku project, without  even renaming the function or  removing the APL
characters useless in Raku.

On the  other hand,  Perl already  knew multiplication  with something
other than  a star. With  x (U+0078, letter  "x"), you can  multiply a
string by a  number or a list by a  number. Unfortunately, the numeric
multiplication was still the horrible star.

By the  way, string  repetition and  list repetition  in Raku  are two
different  operations, respectively  C<x>  and C<xx>.  Do not  confuse
them. You have been warned.

=head3 Another Legacy From APL

In  the  Ace  of  Aces  programs, I  need  to  convert  a  probability
distribution into a  cumulative distribution. If you do  not know what
that means,  I will take another  example. Let us take  a normal year,
without 29th February.  We are given an array with  the number of days
per month.  And we  need to compute  the number of  days from  the 1st
January until the end of each month. The input vector is

  31 28 31 30 31 30 31 31 30 31 30 31

in APL and

  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31

in Raku. Remember that in APL the  indices usually start at 1 and that
in Raku  they start at 0.  Let us call  this vector C<NBD> in  APL and
C<@nbd> in Raku.

If we just want to know how many days are in a year, we just type

  +/NBD
  [+] @nbd

and we get 365. But what about for the number of days from 1st January
until the end of  each month? It is easy in APL,  you just replace the
slash by a backslash.

  +\NBD

which gives

  31 59 90 120 151 181 212 243 273 304 334 365

In  my French-speaking  books on  APL, this  is called  a I<balayage>,
which translates as "sweep". I do not know the English term. Can we do
the  same in  Raku?  Enboldened by  the success  in  the previous  two
paragraphs, I thought  that if a sweep  can be done in APL,  it can be
done also in Raku. And if you use  a backslash in APL, you would use a
backslash also in Raku. So I tried

  [\+] @nbd

and O frabjous day! Callooh! Callay! it works!

  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,  365

Later, in March 2020, I needed another APL operator for my
L<Maya calendar module|https://modules.raku.org/dist/Date::Calendar::MayaAztec:cpan:JFORGET>,
to convert a long count into a number of days or the opposite.
Since you may not be familiar with the Maya calendar, here is
a similar example:

A million of seconds is equal  to how many weeks, days, hours, minutes
and seconds?

      52 7 24 60 60 ⊤ 1000000
  1 4 13 46 40

A million  seconds is one  week, 4 days, 13  hours, 46 minutes  and 40
seconds. Check:

      52 7 24 60 60 ⊥ 1 4 13 46 40
  1000000 

I did not find alone the Raku equivalent. I asked on a
mailing-list and I was redirected to
L<the polymod function|https://docs.raku.org/routine/polymod>
(thank you Laurent). Just one point, the order of parameter is
different from APL:

  say 1000000.polymod(60, 60, 24, 7, 52)
  # --> (40 46 13 4 1 0)

=head3 L-value Substring

when I  learned Perl,  at the  end of  the last  century, there  was a
functionality which thrilled me and made me understand that Perl 5 was
not "just one  more programming language". This  functionality was the
possibility of  using the C<substr>  function in  the left part  of an
assignment:

  substr($_,  0, 0) = "Larry";
  substr($_,  0, 1) = "Moe";
  substr($_, -1, 1) = "Curly";

in I<Programming Perl> 2nd edition, pages 227 and 228.

When I began using Raku, I had no doubt that it would still work. This
shiny idea would obviously be present in Raku.

Well, no. The first time I tried this kind of assignment, I got an error:

  Cannot modify an immutable Str

I did not find anything about modifying a substring in the books where I learned Raku.
I tried the L<online documentation for substr|https://docs.perl6.org/routine/substr>,
nothing either. I had to ask for the
L<list of standard types|https://docs.perl6.org/type.html>.
and then go to the
L<online documentation of type Str|https://docs.perl6.org/type/Str>
to at last find what I needed: the
L<function C<substr-rw>|https://docs.perl6.org/type/Str#method_substr-rw>.

=head3 Functional Notation

Disclaimer: my mother language is  French and I learned mathematics in
French schools.  I know  that there are  some differences  between the
mathematical notations in different countries. I will use the (French)
notation I learned, even if this document is in English.

=for html
<img src='gof.png' width='45%' alt='Graphical representation of the composition of two functions' />

I<Personal pictures. License is the same as for the text.>

When I learned  relations and functions as a  11-year schoolboy, there
was one point  which I did not  like and which was  fooling many other
pupils, the  notation for  composing functions. "f  followed by  g" is
written "g circle  f", not "f circle g". The  alleged justification is
the functional notation suggested by Euler:

     y = f(x)
     z = g(y)

which results in

     z = g(f(x)) = gof (x)

Even  if I  am accustomed  to this  notation where  the functions  are
embedded  within   each  other  and   where  you  have  to   read  the
chronological order right-to-left,  I still do not  like it. Moreover,
nearly  all programming  languages have  followed the  example set  by
Backus'  "formula  translator"  (FORTRAN)   and  use  this  syntaxical
monstruosity. For example, you have a  number C<x>, you apply in order
the  logarithm  function,  the  cosine  function,  the  absolute  part
function and the square root. A graphical representation would be:

=for html
<img src='hogof.png' width='45%' alt='Graphical representation of the composition of four fouctions' />

I<Personal pictures. License is the same as for the text.>

Which would translate in Perl (for example) as:

  $y = sqrt(abs(cos(log($x))))

The only  light of hope  is HP  calculators, and also  TI calculators,
which use the natural order:

  RCL 0
  LN
  COS
  ABS
  SQRT
  RTN

There may  be other languages  such as  Forth and Postscript,  which I
never used, and Smalltalk, which I used very briefly.

And now, there is also Raku:

  $y = $x.log.cos.abs.sqrt;

=head3 Schwartzian Transform

The problem with a Perl Schwartzian Transform:

  my @t2 = map  { $_->[0] }
           sort { $a->[1] <=> $b->[1] }
           map  { [ $_, extr($_) ] } @t;

is that you have to read it from  bottom to top or from right to left,
in the  opposite direction of normal  reading (for people used  to the
Latin  script). This  is similar  to composing  functions while  using
Euler's notation.

With Raku, we have the I<feed> operator  C<< ==> >> which allows us to
imitate the  Unix pipes and  write statements that  read left-to-right
and top-to-bottom. A program would look like:

  use v6;

  my @t = split "---\n", q:to/EOF/;
  Georges Guynemer vanished on 11 September 1917 in the neighborhood of Poelcappelle.
  ---
  On 21 April 1918, Manfred von Richthofen was shot down at Vaux-sur-Somme. Was he downed by the
  canadian pilot Albert Roy Brown or by the artillerymen from the 53rd Australian Battery?
  ---
  First aerial victory in the East: Pyotr Nikolayevich Nesterov deliberately rammed
  an Austrian Albatros on 8 September 1914.
  ---
  5 October 1914, first Western Front aerial victory by Frantz and Quenault.
  ---
  Charles Nungesser, for some time nicknamed "le Hussard de la Mors", is better known for his failed attempt
  to cross the Atlantic on 8 May 1927 than for his 45 victories.
  ---
  RAF was created on 1st April 1918. April Fool's Day!
  ---
  Sarajevo, 28 June 1914: a mass murder with more than 18 millions deaths and how many wounded...
  ---
  11 November 1918, the nightmare is held off for a score of years.
  EOF

  my %month = qw/January  1    February  2   March     3
                 April    4    May       5   June      6
                 July     7    August    8   September 9
                 October 10    November 11   December 12/;

  my @month = %month.keys;

  sub extr(Str $ch) {
    if $ch ~~ /(\d+)'st'? \s+ (@month) \s+ (\d+)/ {
      return $2 × 10000 + %month{$1} × 100 + $0;
    }
    else {
      return 1e8;
    }
  }

  @t ==> map  { [ $_, extr($_) ] } \
     ==> sort { $^a[1] <=> $^b[1] } \
     ==> map  { $_[0] } \
     ==> my @t1;

  say join "\n", @t1;

A point which bothers me is  the requirement to add backslashes at the
end  of the  lines to  show  that the  statement is  continued on  the
following  line. Like  someone  said during  my 2018  talk,  "It is  a
40-year backward leap". See L<the next point|"Vertical Alignment">.

=head4 Beyond the Schwartzian Transform

After my  2018 talk, someone  told me that there  is a simpler  way to
sort  the texts,  which makes  the  Schwartzian Transform  a bit  less
useful. For the frequent case where  there is only one sort criterion,
you can replace the comparison function with a function extracting the
sort criterion. So the feed statement would be reduced to:

  @t ==> sort { extr($_) } \
     ==> my @t1;

With this syntax, Raku ensures the extraction and storing of criterion
values and  then the removing of  these values. You no  longer need to
code the  two C<map> steps. By  including a C<print> statement  in the
C<extr> function,  you can check  that the C<extr> function  is called
only once per record.

The Schwartzian  Transform is  still useful for  multi-criteria sorts.
With the same example as above, let us suppose we have three different
functions  for extracting  the  year,  the month  number  and the  day
number. The statement would become:

  @t ==> map  { [ $_, year($_), month($_), day($_) ] } \
     ==> sort { $^a[1] <=> $^b[1] || $^a[2] <=> $^b[2] || $^a[3] <=> $^b[3] } \
     ==> map  { $_[0] } \
     ==> my @t1;

More verbose and less stylish.

=head3 Vertical Alignment

In my  opinion, vertical alignment  is an important factor  to improve
the readability of  code and to help  a human understand it.  I do not
speak only  of code indentation  for the first non-space  character. I
speak  about  aligning  similar  elements  on  successive  lines.  For
example, in Perl I can write:

  $length[$n] = $length[$n - 1] + $dx;
  $width [$n] = $width [$n - 1] + $dy;

On the other hand, in Raku, the following is syntactically incorrect:

  @length[$n] = @length[$n - 1] + $dx;
  @width [$n] = @width [$n - 1] + $dy;

Because no  space can exist between  the array's name and  the opening
square bracket. The right syntax is horrible:

  @length[$n] = @length[$n - 1] + $dx;
  @width[$n] = @width[$n - 1] + $dy;

I ended with this compromise:

  @length[$n] = @length[$n - 1] + $dx;
  @width[ $n] = @width[ $n - 1] + $dy;

All similar elements are aligned, except the opening square brackets.

There  is  an  interesting  syntax functionality,  which  has  already
appeared  in  the  paragraph  about  the  Schwartzian  Transform,  the
I<unspace>. If there is a backslash followed by any whitespace (space,
tab, line feed,  etc), the Raku parser ignores this  backslash and all
consecutive whitespace chars. These two lines are equivalent:

  @length[$n]
  @length\         [$n]

In the  paragraph about the  Schwartzian Transform, the  backslash was
used to virtually  remove the linefeed (and all  following spaces), so
the Raku  parser would  see a  complete statement  on one  single line
while the human reader would see a statement on four successive lines,
each one with a medium length.

Could  the  I<unspace> be  useful  for  my length/width  example?  No,
because adding  a backslash to inhibit  the space on the  "width" line
would shift  the line alignment with  one additional char. So  I would
have to insert a space in the "length" line also. And this space would
need  to be  inhibited  with another  backslash.  Which would  require
adding yet  another space in the  "width" line. The result  would have
been:

  @length\ [$n] = @length\ [$n - 1] + $dx;
  @width\  [$n] = @width\  [$n - 1] + $dy;

There are  other ways to ensure  a vertical alignment. One  is to make
deliberate spelling mistakes:

  @length[$n] = @length[$n - 1] + $dx;
  @widthh[$n] = @widthh[$n - 1] + $dy;

Another way  is to use a  module which changes Raku's  syntax to allow
whitespace where the  standard syntax rejects them. I  do not remember
the name of the module or of its author. What a pity!

=head3 Regexes, formerly Regular Expressions

=head3 Value and Variable Types

=head2 MongoDB

I have installed MongoDB on my  computer with the packages provided by
the distribution. Nothing more to say.

The  installation of  the  Raku  module for  MongoDB  was  a bit  more
eventful.  Please note  that I  describe here  the situation  in March
2018. Things  has moved on since  this time. Some advices  given below
are still relevant, others are obsolete.

First try:

  zef install MongoDB

Some tests  fails. The F<README> file  tells me that this  is expected
and that I should not bother about these few failed tests. Second try:

  zef install --/test MongoDB

It  is  installed.  I  copy-paste  an  example  script  from  the  POD
documentation. It fails!  I quickly finds it is caused  by a debugging
statement:

     debug-message("command done {$command.find-key(0)}");

I find  the source file  in the F<.zef/store> directory  for installed
modules and I remove the debugging statement. This is not recommanded,
but from time to time I do  this in Perl, for a quick-and-dirty check,
followed  soon after  by a  clean  reinstallation of  the module.  The
problem is  that when a Raku  module is installed, the  code files are
stored in  two formats, a  bytecode format used  by the runtime  and a
text format which is ignored by  the runtime. The example script still
fails, because the bytecode file has not changed.

I clone the
L<Git Hub repo|https://github.com/MARTIMM/mongo-perl6-driver/>, 
I remove the debugging message, and I reinstall the module with:

  zef install --/test .

That is, installing  what is in the current  directory. C<zef> refuses
to install the module, because the  module is up-to-date, or so C<zef>
says. After reading the on-line help, I type

  zef install --force --/test .

Is  this the  right thing  to do?  I do  not know,  but I  suppose so,
because  at  least the  module  is  installed. And  the  copied-pasted
example now works, prrovided I remove the C<findAndUpdate> line, which
does not exist in version 2.6 of MongoDB.

When I try to  write and run my own programs,  I have another problem,
something about unkept promises. After many tries, I conclude that for
each C<find> statement the parameters should include

      projection => ( _id => 0, )

That  is, extract  all attributes  of the  document, except  attribute
C<_id>. Why?  I do not know.  All I know  is that it always  fail when
C<_id> is included, it usually succeed when C<_id> is excluded. Now, I
always type the  exclusion in all my C<find> statements.  Maybe that a
few  years later,  I should  once more  try a  C<find> statement  with
C<_id>?

I  have mentioned  "after  many tries".  The problem  is  that I  have
zigzagged a  lot and I have  done the same attempts  several times. To
prevent this waste  of time, I have decided to  write a cookbook, with
all the  C<find> variants I  have tried  and with the  resulting error
messages.

For example, note that a C<find>  statement in a Raky program will not
accept  the options  C<sort>,  C<limit>  and C<skip>.  This  is not  a
problem  of  old MongoDB  version  2.6  vs up-to-date  MongoDB,  these
options are described in the 2013 O'Reilly book, on page 68.

With MongoDB,  there is a variant  of the problem I  have described in
L<Value and Variable Types>. MongoDB knows about integers C<(Int)> and
floats C<(Num)>, but not rational  numbers C<(Rat)>. The error message
with the 2018 is rather cryptic:

  2018-05-25 05:31:06.093687 [E]  1: localhost:27017: encode() on 1.5, error: Not yet implemented
  . At site#sources/9F1921D0AA42F2C1C0229F51082ED0A3E384968C (MongoDB::Wire):112
  2018-05-25 05:31:06.097117 [E]  1: No server reply on query. At site#sources/C727D6F914B4AE4082E938B9310DC8D2F4CD7B53 (MongoDB::Collection):101 in find()
  2018-05-25 05:31:06.098900 [E]  1: No cursor returned. At site#sources/BC4819BBBB818C799983157518CA75F0C1A6DFC7 (MongoDB::Database):73 in run-command()

The error message  with the 2021 version is not  only cryptic but also
very long, displaying the complete stack of program calls.

The minimum work example would be:

  use v6;
  use BSON::Document;
  use MongoDB::Client;
  use MongoDB::Database;
  use MongoDB::Collection;

  my MongoDB::Client     $client  .= new(:uri('mongodb://'));
  my MongoDB::Database   $database = $client.database('example2');
  my MongoDB::Collection $coll     = $database.collection('example2');

  my BSON::Document $doc .= new: (
       number => 1.5,
       );
  my BSON::Document $req .= new: (
    insert => 'example2',
    documents => [ $doc ],
    );

  my BSON::Document $result = $database.run-command($req);
  say "Création example2 ok : ", $result<ok>, " nb : ", $result<n>;

After the French  Perl Workshop 2018 was over, I  upgraded my computer
to xubuntu-18.04 64-bits and MongoDB 3.6.3 and I installed Rakudo Star
from the sources. Then I tried to install the MongoDB module with:

  zef install MongoDB

This failed  because there was  no F<libssl.so> on my  computer. There
were   a   F<libssl3.so>   lib,   a   F<libssl.so.1.1>   lib   and   a
F<libssl.so.1.0.0>  lib, but  it seems  that MongoDB  does not  accept
them. So I typed the no-test variant:

  zef install --/test MongoDB

And the  installation succeeded. I  tried a few  Raku+MongoDB programs
and they worked at first try. The situation has improved between March
2018 and June 2018.

Remark: I did not check whether the problem with C<_id> is still there
and whether I still need to add

      projection => ( _id => 0, )

On the  other hand, I have  checked the C<(Rat)> problem,  it is still
here.

And in 2021, the C<_id>  problem has disappeared, the C<(Rat)> problem
is still here.

=head2 Bailador

At first, I had no intention  of producing dynamic webpages within the
scope  of this  project. Then  I found  that reading  the database  in
proper webpages with convenient hyperlinks was easier than reading the
raw JSON output of a request written in JavaScript.

So I  installed Bailador, the  Raku equivalent of Perl's  Dancer. What
can I  add? I installed  the module,  it worked without  fuss. Nothing
cheesy to add.

I must admit that  the way I use Bailador in this  project is as basic
as the  way I used Dancer2  in my 2017 character  recognition project.
Even more basic, because I do not  even use HTML forms. By the way, do
not expect to have as many
L<modules for Bailador|https://modules.perl6.org/t/WEB>
as what you can find
L<for Dancer2|https://metacpan.org/search?q=Dancer2>.
You will have to wait a little. Or you may volunteer to fill the gaps.

One more  point. I do  not know the  MVC architecture (except  for the
expanded  name, I<Model,  View, Controller>).  Yet I  have decided  to
split my Bailador program into  several source files. The first, named
F<site.p6>,  corresponds in  my  mind to  the  Controller. The  second
source  file, in  a subdirectory  and named  F<lib/acces-mongodb.pm6>,
would be the  model. And a few  others, fichiers F<lib/site-coup.pm6>,
F<lib/site-liste-parties.pm6> and F<lib/site-partie.pm6>  would be the
Views. I can call the  functions of F<lib/acces-mongodb.pm6>, from the
Controller F<site.p6>,  but not from the  Views F<lib/site-xxx.pm6>. I
still have some things to learn about C<use> and C<require> in Raku.

=head1 Conclusion

I like Raku very much. I had some projects for which I intended to
use APL. Maybe I will use Raku instead.

About choosing  Ace of Aces for  a Google Alpha Go  Zero-like project,
you must remember it is a game simpler than Chess and Go. More complex
than Tic-Tac-Toe, but  way much simpler that both  classic games. This
is  why I  have been  able to  create a  "Alpha Ace  of Aces  Zero" by
myself,  on a  datacenter consisting  of  a single  PC with  mid-range
performance.

=head1 License

This text is published under the CC-BY-NC-ND license: Attribution-NonCommercial-NoDerivs 2.0 Generic.

Some pictures might have a different license. In this case, it is shown after the picture.
