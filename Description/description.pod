-*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf-8

=head1 L'As des AS

=head2 Rappel

L'an dernier, j'ai présenté un système de reconnaissance
de caractères basé sur une interface entre un humain (fournissant
le moteur de reconnaissance de caractères) et une
machine (pour la base de données). J'aurais pu le présenter autrement.

=for html
<img src='comparaison-l-1.png' alt='Comparaison entre une cellule l (Lima) et un glyphe 1 (unité)' />

I<Copie d'écran personnelle. Les conditions de licence sont les mêmes que pour le texte.>

-- Maître, cette cellule contient un chiffre « 1 ».

-- Petit Scarabée, c'est la lettre « l ».

-- Ah, maître, je comprends la nature du « l ».

Présenté comme cela, vous avez reconnu, c'est du I<machine learning>
ou plus précisément du I<supervised machine learning>
(et ça fera bien dans mon CV).

=head2 Cette année

Récemment, nous avons appris que Google avait fait du I<supervised machine learning>
avec Google Alpha Go. Puis nous avons appris qu'ils avaient fait
une autre expérience sur le jeu de Go,
Google Alpha Go Zero, basé sur un mécanisme d'auto-apprentissage, ainsi
que l'équivalent pour les échecs, Google Alpha Chess Zero.
Le système ne connaît que les règles du jeu et le fait qu'une position
finale est gagnante ou perdante. Le système joue un grand nombre de
parties contre lui-même, analyse les résultats et en déduit les positions
et coups avantageux et les positions et coups foireux.

Cette idée ne date pas de 2017 ou 2018, je l'ai déjà rencontrée dans
les années 1970 avec le tic-tac-toe. Et depuis longtemps j'avais moi-même un projet
de « machine self-learning », que je vous présente ci-dessous.

=head2 Digression sur les précurseurs des liens hypertextes

Quand a-t-on commencé à numéroter les pages des livres (ou des rouleaux de papyrus) ?
Quand a-t-on écrit pour la première fois "cf. page n" ?
Quand a-t-on pensé à ajouter un index des mots importants en fin d'ouvrage ?
Quand a-t-on écrit un ouvrage qui utilise de façon I<intensive> les renvois
à une autre page ?

À la suite des travaux des naturalistes du XVIIe siècle (Jussieu, Buffon, Cuvier, etc)
on a commencé à publier des flores, des livres décrivant l'ensemble des végétaux
d'une région ou d'un biotope. Mon père m'en a montré une datant des années 1950
et qui était organisée sous la forme d'une série de questions-réponses :

=for html
<blockquote>

Comment sont les nervures des feuilles ? Si elles sont parallèles, voyez page 17.
Si elles forment un réseau arborescent avec une nervure centrale, des nervures primaires
se détachant de la nervure centrale, des nervures secondaires se détachant d'une nervure
primaire et ainsi de suite, voyez page 33.

=for html
</blockquote>

Page 17 et page 33 vous aviez d'autres questions, d'autres réponses et d'autres renvois.

Années 1960 (je crois) : on m'a raconté qu'à cette époque IBM avait composé des
manuels de dépannage sur le même principe :

=for html
<blockquote>
Si de la fumée sort de l'unité de disque, voyez page 17.
Si cela fait « crrr crrr crrr » voyez page 33.

=for html
</blockquote>

Dans les années 1970, j'ai vu à la télévision le sketch d'un duo d'humoristes
sur « le dictionnaire le plus petit du monde ». Ce qui prend de la place dans un dictionnaire
ce sont les définitions. Donc, en éliminant les définitions, on peut imprimer un
dictionnaire complet sur un livre de poche. Exemple

  Clown : voir Cirque.
  Cirque : voir Cercle.
  Cercle : voir Club
  Club : voir Assemblée
  Assemblée : voir Parlement.
  Parlement : voir Député.
  Député : voir Politicien.
  Politicien : voir Clown.

=head3 Le Sorcier de la Montagne de Feu

En 1982, est paru un livre d'un genre nouveau,
L<Warlock of the Firetop Mountain|http://fightingfantasy.wikia.com/wiki/The_Warlock_of_Firetop_Mountain_(book)>, 
bientôt traduit en français par
L<Gallimard Folio Junior|http://planete-ldvelh.com/page/dossier-edition-gallimard.html> 
sous le titre
« le Sorcier de la Montagne de Feu », le premier de la série
L<« les Livres dont vous êtes le héros »|http://www.gallimard-jeunesse.fr/Catalogue/GALLIMARD-JEUNESSE/Un-Livre-dont-vous-etes-le-Heros>.

=for html
<blockquote>

Paragraphe 1. Vous entrez dans une auberge. Au fond de la salle, vous voyez l'aubergiste à
son comptoir en train d'essuyer des verres. À gauche, dans un
recoin sombre, un homme seul à une table, la tête masquée par un
capuchon noir. Sur la droite, une demi-douzaine de nains des
montagnes boivent de la bière en rigolant bruyamment. Que faites-vous ?
Vous vous adressez à l'aubergiste, allez au paragraphe 17. Vous
vous asseyez à côté de l'homme encapuchonné, allez au paragraphe 33.
Vous vous adressez aux nains en leur disant S<« Salut> les ornements de 
S<jardin ! »> allez au paragraphe 52. 

=for html
</blockquote>

J'en ai eu cinq, dont deux édités par Gallimard et trois par Solar, il m'en reste quatre.

=for HTML
<img src='Les_livres_dont_vous_etes_le_heros.jpg' alt="Quatres livres dont vous êtes le héros" width='85%' />

I<Photo personnelle. Les conditions de licence sont les mêmes que pour le texte.>

=head2 L'As des As

En 1981, un dénommé Alfred Leonardi a déposé un brevet pour un
nouveau type de jeu. Au lieu de réunir les deux joueurs sur une même
carte où ils poussent des pions, chaque joueur est muni d'un livret.

=for HTML
<img src='pic1051809-l.jpg' alt="Exemple de partie" width='85%' />

I<Photo prise par Chris Norwood et publiée sur L<Boardgame Geek|https://boardgamegeek.com/image/1051809/ace-aces-handy-rotary-series?size=large>. 
Licence L<Creative Commons Attribution 3.0 Unported, CC BY 3.0|https://creativecommons.org/licenses/by/3.0/>.>

=head3 Aperçu des règles

Le brevet donne un exemple de tour de jeu. Les deux joueurs commencent page 1. Dans
les deux livrets, cette page montre que les deux avions ont le même cap et
que le DR1 est dans les 4 heures du Camel, c'est-à-dire que le Camel est dans
les 10 heures du DR1.

=for HTML
<img src='Page-1-All.png' alt="Livret allemand page 1" width='45%' />
<img src='Page-1-GB.png' alt="Livret britannique page 1" width='45%' />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

En bas de la page, vous pouvez remarquer une série de flèches et une
série de nombres, des numéros de page. Chaque joueur choisit une flèche et
annonce le numéro de page correspondant à son adversaire. Par exemple, le joueur
allemand choisit la flèche la plus à gauche dans la page et annonce :

-- Je t'envoie en page 8.

=for HTML
<img src='Manoeuvre-1-8.png' alt="Page 1, flèche pointant vers la page 8" width='25%' />
<img src='Manoeuvre-1-48.png' alt="Page 1, flèche pointant vers la page 48" width='25%' />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Simultanément, le Britannique choisit la manœuvre en dessous de S<« EF »>
S<« Cruising> S<Left »> et répond :

-- Et toi, tu vas page 48.

Le joueur allemand ouvre son livret page 48 et applique la même manœuvre que
précédemment, ce qui donne la page 96. De même, le joueur britannique ouvre
son livret page 8, repère la manœuvre choisie et obtient le même numéro de page, 96.

=for HTML
<img src='Page-48-All.png' alt="Livret allemand page 48" width='45%' />
<img src='Page-8-GB.png' alt="Livret britannique page 8" width='45%' />
<img src='Manoeuvre-48-96.png' alt="Page 48, flèche pointant vers la page 96" width='25%' />
<img src='Manoeuvre-8-96.png' alt="Page 8, flèche pointant vers la page 96" width='25%' />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

La page finale du tour est donc la page 96. Et comme vous pouvez le voir,
non seulement l'As des As est un précurseur des liens hypertextes, mais
c'est aussi un précurseur des jeux de tir en vision subjective
(I<First Person Shooters> en anglais), une douzaine d'années avant Wolfenstein 3D et Doom.

=for HTML
<img src='Page-96-All.png' alt="Livret allemand page 96" width='45%' />
<img src='Page-96-GB.png' alt="Livret britannique page 96" width='45%' />

I<Copies d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Quant au mécanisme des tirs, c'est très simple. Vous commencez avec 12 points de vie. 
Chaque fois que vous aboutissez sur une page finale où vous recevez des pruneaux de l'avion
ennemi, vous perdez 1, 2 ou 4 points de vie, selon la page finale. On ne tient pas
compte des pages intermédiaires. Quand votre total de points de vie
est négatif ou nul, votre avion est abattu.

=head3 Dissection du mécanisme

Avec ce mécanisme, les pages finales sont toujours identiques. Cela émerveille les joueurs
qui découvrent le jeu, mais cela peut s'expliquer simplement. Oublions les cieux au-dessus
de L<Poelcapelle|http://acepilots.com/wwi/fr_guynemer.html> 
et de L<Vaux-sur-Somme|http://military.wikia.com/wiki/Manfred_von_Richthofen>,
et imaginons un parking de supermarché. Toutes
les voitures sont garées à proximité du bâtiment et il y a donc un large espace libre un
peu plus loin. Dans cet espace libre, se trouvent une Mini Austin et une VW Coccinelle
disposées ainsi :

=for html
<img src='voitures-0.png' width='45%' alt='Position de départ des deux voitures' />
<img src='Page-1-GB.png' alt="Livret britannique page 1" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Cela correspond à la page 1 des deux livrets.

Maintenant, imaginons que la VW fasse ce mouvement pendant que la Mini reste immobile.

=for html
<img src='voitures-1.png' width='45%' alt="Mini dans sa position de départ et VW dans sa position d'arrivée" />
<img src='Page-8-GB.png' alt="Livret britannique page 8" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

On obtient alors la disposition de la page 8. À ce moment-là, la Coccinelle s'arrête
et l'Austin démarre en faisant ce mouvement

=for html
<img src='voitures-2.png' width='45%' alt="Position d'arrivée des deux voitures" />
<img src='Page-96-GB.png' alt="Livret britannique page 96" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Le résultat est celui de la page 96.

=for html
<img src='voitures-3.png' width='45%' alt="Position d'arrivée des deux voitures" />
<img src='Page-96-GB.png' alt="Livret britannique page 96" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Deuxième étape de l'expérience. Les deux voitures se remettent dans la disposition correspondant à la page 1.

=for html
<img src='voitures-0.png' width='45%' alt='Position de départ des deux voitures' />
<img src='Page-1-All.png' alt="Livret allemand page 1" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Puis c'est la Mini qui bouge la première pendant que la VW reste immobile.
On aboutit alors à la disposition de la page 48.

=for html
<img src='voitures-4.png' width='45%' alt="VW dans sa position de départ et Mini dans sa position d'arrivée" />
<img src='Page-48-All.png' alt="Livret allemand page 48" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Et lorsque la Coccinelle effectue son mouvement, on aboutit à la configuration de la page 96.

=for html
<img src='voitures-5.png' width='45%' alt="Position d'arrivée des deux voitures" />
<img src='Page-96-All.png' alt="Livret allemand page 96" width='45%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Troisième étape. Les voitures se remettent dans la position de la page 1, puis elles effectuent
I<simultanément> leur mouvement. Comme les deux fois précédentes, on obtient la disposition de
la page 96.

=for html
<img src='voitures-6.png' width='30%' alt="Position d'arrivée des deux voitures" />
<img src='Page-96-GB.png' alt="Livret britannique page 96" width='30%' />
<img src='Page-96-All.png' alt="Livret allemand page 96" width='30%' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>
I<Copie d'écran provenant du brevet USP 4,378,118, dans le domaine public depuis 2001.>

Ainsi donc, il est équivalent de faire les mouvements simultanément ou de les faire séquentiellement
dans un ordre ou dans l'autre. Et ce, aussi bien sur un parking de supermarché que dans
l'espace aérien de la Picardie ou des Flandres.

=head3 Cas particulier, la page 223.

Un livret n'a qu'un nombre limité de pages, correspondant à une distance limitée entre les
deux avions. Si, du fait de leurs manœuvres, les avions se retrouvent plus loin que cette
distance limite, le livret affiche une page spéciale, la page 223 qui représente des
nuages derrière lesquels l'ennemi a disparu. Même si cette page montre le ciel en avant de l'avion,
il est possible que l'ennemi ait disparu sur un côté ou derrière.

Si un seul joueur a une page intermédiaire à 223, on utilise la page intermédiaire de l'autre
pour obtenir la page finale. Impossible dans ce cas de faire la vérification présentée, expliquée et démythifiée
au paragraphe précédent. Un tel cas de figure se produit par exemple lorsque les deux avions se poursuivent
à grande distance. Supposons que nous soyons page 180, où le Camel est à longue distance
dans les onze heures du DR.1 et supposons que les deux avions avancent tout droit à vitesse
moyenne. Si l'on applique d'abord le mouvement du Camel, le DR.1 le perd de vue temporairement et la page
intermédiaire est la page 223, sur laquelle aucune manœuvre n'est indiquée. En revanche, si
l'on applique d'abord la manœuvre du DR.1, la page intermédiaire est la page 60 où 
le Camel est à distance moyenne dans les 10 heures du DR.1. Puis on applique le mouvement
du Camel, ce qui donne la page 180. Il n'est plus possible de vérifier que la page
finale est la même selon les deux déterminations, mais tant pis.

D'un autre côté, si les deux pages intermédiaires sont 223, ou bien si la page finale est
223, alors les avions se sont perdus de vue. Chaque joueur décide alors de continuer le
combat ou de s'éclipser. Si les deux avions fuient, c'est un match nul. Si les deux
avions décident de continuer, le combat reprend sur une page avec une position neutre, chaque avion
conservant les dégâts déjà subis. Si un seul avion fuit, il accorde une demi-victoire
à son adversaire, mais c'est parfois préférable, plutôt que de prendre le risque de se
faire descendre et d'accorder ainsi une victoire complète à son adversaire.

=head3 Autre cas particulier, la poursuite

Lorsqu'un avion est dans le quadrant arrièrre d'un autre (4 à 8 heures) et que
son cap est identique ou presque, alors on dit qu'il poursuit l'autre avion.
C'était le cas sur la page 1 présentée ci-dessus. Pour des raisons pédagogiques,
j'ai préféré faire le silence sur cette particularité.
La simultanéité du choix des manœuvres est partiellement annulée. La séquence est la suivante

=over 4

=item 1 L'avion poursuivi choisit une manœuvre.

=item 2 Il indique au poursuivant s'il s'agit d'une manœuvre vers
la gauche, d'une manœuvre vers la droite ou d'une manœuvre en ligne droite
vers l'avant. Il ne donne pas le numéro de la page intermédiaire.

=item 3 L'avion poursuivant choisit une manœuvre.

=item 4 Les deux joueurs annoncent simultanément les pages intermédiaires.

=item 5 Les deux joueurs déterminent la page finale.

=back

=head3 Considérations diverses

Lors d'un tour de jeu, vous devez garder à l'esprit :

=over

=item 1 le numéro de la page initiale,

=item 2 la manœuvre choisie

=item 3 la page intermédiaire que vous communiquez à votre adversaire,

=item 4 la page intermédiaire que votre adversaire vous indique,

=item 5 la page finale du tour,

=item 6 le nombre de points de dégâts encaissés,

=item 7 optionellement le nombre de points de dégâts infligés à votre adversaire.

=back

On dit que la mémoire à court terme d'un humain contient 7 ± 2 informations (à part les serveurs
de café, qui dépassent largement cette valeur). À moins d'être
dans la catégorie inférieure, il est possible de jouer à l'I<As des As> sans avoir besoin
de noter quoi que ce soit, ni de déplacer des marqueurs sur des tableaux. Il est possible
de jouer à la plage, il est possible de jouer à côté de la machine à café,
il est possible de jouer dans une salle d'attente, il est possible
de jouer dans le bus. Et si vous êtes dans une catégorie supérieure pour cette faculté,
vous pouvez même jouer dans le bus tout en gardant un œil sur les arrêts restants avant
votre destination.

=head3 Extensions

Deux extensions sont sorties avec des avions plus récents (I<Powerhouse> : Spad XIII contre Fokker D.VII) ou plus anciens
(I<Flying Machines> Airco DH2 contre Fokker E.III). Également, il y a la version Seconde Guerre Mondiale (I<Wingleader>, P-51 Mustang
contre FW190), la version Guerre Froide (I<Jet Eagles>, F-15 Eagle contre MiG-29 Fulcrum) et 
même la version Guerre des Étoiles (I<Star Wars : Starfighter Battle Books>, X-Wing contre TIE-Fighter, extension publiée par West End Games).

À remarquer que toutes ces versions ont la même pagination. Dans tous les livrets, la page 96 montre
le « méchant » derrière le « gentil », à distance moyenne, avec le même cap et en train de lui tirer dessus.
Il est possible de jouer avec un livret « gentil » d'un jeu et un livret « méchant » d'un autre jeu, quitte
à faire combattre un X-Wing contre un Fokker E.III !

Attention au sujet de I<Wingleader> : il existe un autre jeu beaucoup plus récent du
même nom chez GMT. Si vous êtes intéressé par le jeu décrit et que vous voulez l'acheter
par correspondance, vérifiez bien qu'il s'agit du bon jeu.

=begin html

<img src='Serie_As-des-As.jpg' alt="L'As des As, les jeux de la Première Guerre Mondiale " width='45%' />
<img src='Wingleader_Jet_Eagles.jpg' alt="L'As des As, Seconde Guerre Mondiale et Guerre Froide" width='45%' />

=end html

I<Photos personnelles. Les conditions de licence sont les mêmes que pour le texte.>

=begin html

<img src='Jet-Eagles-96M.jpg' alt="Page 96 pour Jet Eagles, livret 'Red Force'" width='45%' />
<img src='Jet-Eagles-96G.jpg' alt="Page 96 pour Jet Eagles, livret 'Blue Force'" width='45%' />

=end html

I<Photos personnelles reprenant une page dans les deux livrets de Jet Eagles, copyright © 1990 Nova Game Designs, Inc.>

Toutes ces variantes proposent également des règles avancées, pour
l'altitude par exemple, ou le jeu 2-contre-2, ou
encore pour les radars et les missiles dans le cas de I<Jet Eagles>.
Hélas, ces règles avancées font perdre la compatibilité avec la capacité 7 ± 2 de la mémoire à court terme.
À part une règle sur la compatibilité entre deux manœuvres successives
d'un même avion, je n'ai pas l'intention de les prendre en compte dans
mes programmes.

Il y a également une extension I<Balloon Busters>, où l'on fait du 2-contre-1. Le joueur allemand
contrôle un ballon d'observation (assez passif) plus un canon anti-aérien, contre un avion britannique.

Autres extensions dans la même lignée, mais impossibles à mélanger avec les premières :
I<Shootout at the Saloon> traduit chez Gallimard avec le titre
I<Le shérif et le hors-la-loi>,
I<Dragons Riders of Pern> traduit par Gallimard avec le titre
I<les Maîtres des Dragons> et une série dont je n'avais jamais entendu parler
avant de rédiger ces explications, I<Lost Worlds>.

=begin html

<img src='Le_sherif_et_le_hors-la-loi.jpg' alt="Le Shérif et le Hors-la-loi" width='30%' />
<img src='Sherif.jpg' alt="Le shérif apercevant le hors-la-loi" width='30%' />
<img src='Hors-la-loi.jpg' alt="Le hors-la-loi apercevant le shérif" width='30%' />

=end html

I<Photos personnelles reprenant « Le Shérif et le Hors-la-loi », Copyright © 1982 Nova Games Design Inc, copyright © 1986 Emithill Limited,
copyright © 1986 Gallimard pour la traduction française et pour les illustrations de couverture.>

=begin html

<img src='Mai-68-A.jpg' alt="Mai 68, première édition" width='45%' />
<img src='Mai-68-B.jpg' alt="Mai 68, deuxième édition" width='45%' />

=end html

I<Photos personnelles reprenant le jeu "Mai 68" de F. Nédelec et D. Vitale, Copyright © 1980, 1982, 1988>

Oups ! Qu'est-ce que cela vient faire dans cet exposé sur le centenaire de la RAF et sur
le centenaire de l'armistice ?

Pour en revenir au combat aérien, puisque le brevet est tombé dans le domaine public,
n'importe qui peut publier des extensions dans la lignée :

=over 4

=item * Apache AH-64 vs Mi-24 Hind

=item * Quidditch : Griffindor vs Slytherin

=item * Superman vs Ironman

=item * Épervier vs drone de loisir

=back

C'est d'ailleurs cette dernière extension que j'ai choisie pour disposer de données
de tests dans mes programmes. J'étais réticent à reprendre les caractéristiques des
avions de l'un des jeux existants, car si le brevet est expiré, le copyright ne l'est pas.

=head1 Description des programmes

Il y a deux grandes parties dans le projet. Tout d'abord, la préparation,
consistant à regénérer plutôt que recopier les enchaînements entre pages
et manœuvres. Puis il y a le jeu proprement dit où des programmes combattent
l'un contre l'autre.

=head2 Préparation

J'ai commencer par programmer cette partie, bien sûr. Je l'ai faite avant d'initialiser
le dépôt Git. Du coup, les programmes sont dans un répertoire extérieur.
J'ai l'intention de réintégrer ces programmes dans le dépôt Git, avec une
phase de nettoyage. Vous ne verrez donc pas mes tout premiers pas en Perl 6.

=head2 Jeu

Le jeu entre humains est prévu pour deux joueurs sans arbitre.
Pour les programmes, j'ai préféré utiliser un programme arbitre,
ou plutôt un processus arbitre,
communiquant avec deux processus joueurs. Les deux processus
joueurs fonctionnent avec le même programme Perl 6, mais avec des
arguments d'appel différents.

Pour rester dans la même optique que Google Alpha Go Zero et Google Alpha Chess Zero,
le programme joueur n'a aucune connaissance intrinsèque des mécanismes de vol
et des doctrines de combat aérien. Il se contente de recevoir une liste
de manœuvres de l'arbitre, d'en sélectionner une et de renvoyer la réponse
à l'arbitre.

Le programme joueur fonctionne en deux modes. Il y a le mode entraînement
où le choix est totalement aléatoire. Et il y a le mode combat où le
programme joueur extrait de la base de données les situations analogues
pendant les parties précédentes pour savoir ce qui a bien marché et
ce qui n'a pas donné de bons résultats. Il attribue des probabilités 
plus ou moins élevées aux
différentes manœuvres proposées par le programme arbitre et tire au
hasard une manœuvre, en tenant compte de la loi de probabilité attribuée.

Le programme arbitre, lui, a une meilleure connaissance des mécanismes
de vol et de tir, mais rien sur la tactique ni la doctrine.
C'est lui qui lit le fichier JSON créé par les programmes de préparation
et qui connaît ainsi à quelle page on aboutit lorsque l'on exécute
telle manœuvre sur telle page de départ.

=head3 Communication inter-processus

Ainsi donc, il y a trois processus qui s'échangent des informations.
Ai-je eu recours à des sockets ? À des messages mis en file d'attente ?
Non. Je me suis inspiré d'un mécanisme que l'on voit couramment
dans les romans d'espionnage de John le Carré ou du même style,
la S<« boîte> aux S<lettres »>. L'officier traitant donne ses instructions
sur un microfilm qu'il dépose dans un endroit discret S<convenu :>
souche d'arbre, fissure entre deux briques, vous voyez le genre.
L'espion récupère le microfilm, effectue les recherches demandées
et livre les résultats au même endroit. Et l'officier
traitant récupère les documents secrets de la même manière. C'est pareil entre
le processus arbitre et les processus joueurs. L'arbitre écrit dans
la base de données un enregistrement pour chaque joueur.
Le processus joueur lit l'enregistrement qui le concerne, le met
à jour et le réécrit dans la base. Puis l'arbitre lit l'enregistrement
modifié.

Comme dans les romans de John le Carré, si un processus ne trouve pas
l'enregistrement attendu dans la boîte aux lettres, il attend un petit peu
et il refait une tentative de lecture. Et comme dans les romans de John le Carré,
au bout d'un nombre important de tentatives infructueuses, le processus considère qu'il s'est passé
quelque chose de louche et il arrête toute activité. La métaphore s'arrête là, car
d'un côté l'espion se fait exfiltrer et survit, de l'autre côté le processus
effectue un C<die>.

S<« Quand> on a un marteau, tout ressemble à un S<clou. »> Certes, mais en procédant de
la sorte, je n'avais qu'un module avec des bugs qu'il fallait contourner.

=head1 Perl 6

=head2 Installation

Je connais quatre méthodes pour installer Rakudo Star sur une machine Linux.

=over 4

=item 1

Installer le paquet F<.rpm> ou F<.deb> fourni par votre distribution.

=item 2

Installer le paquet F<.rpm> ou F<.deb> fourni par un L<volontaire|https://github.com/nxadm>
dans un L<dépôt Github|https://github.com/nxadm/rakudo-pkg/releases>

=item 3

Récupérer une image Docker, comme le propose Moritz Lentz dans son livre I<Perl 6 Fundamentals>.

=item 4

Compiler à partir des sources.

=back

Dans mon cas, la deuxième méthode est inapplicable (pas de paquet pour
xubuntu 16.10) et la première méthode donne des versions vraiment trop
anciennes. Mes différentes machines physiques et virtuelles et les
paquets correspondants sont :

  physique    xubuntu-12.04   rakudo 2011.07
  virtuelle   xubuntu-14.10   rakudo 2013.12
  virtuelle   lubuntu-15.10   rakudo 2014.07
  physique    xubuntu-16.10   rakudo 2016.06
  virtuelle   Mageia-5        pas trouvé

Pour Docker, il faudrait d'une part que Docker soit installé sur ma machine, d'autre
part que je sois à l'aise avec Docker. Or Docker n'est pas installé et les dépôts xubuntu 16.10
ne sont plus disponibles depuis un certain temps. Et je ne maîtrise pas l'utilisation
de Docker.

Du coup, j'ai installé rakudo star 2018.01 à partir des sources. La première fois que
j'ai compilé rakudo star, cela a pris beaucoup de temps, plusieurs heures.
La deuxième fois, pour éviter d'avoir à surveiller ma machine pour saisir la
commande suivante (C<make>, C<make test>, C<make install>), j'ai écrit un script
qui enchaîne ces commandes et donne la date et l'heure entre deux.

  #!/bin/sh
  # -*- encoding: utf-8; indent-tabs-mode: nil -*-

  interlude() {
    echo
    echo
    date +'%Y-%m-%d %H:%M:%S'
    echo
    echo
  }

  mkdir ~/rakudo && cd $_
  wget https://rakudo.perl6.org/downloads/star/rakudo-star-2018.01.tar.gz
  interlude
  tar -xvzf rakudo-star-2018.01.tar.gz
  interlude
  cd rakudo-star-2018.01/
  interlude
  perl Configure.pl --backend=moar --gen-moar
  interlude
  make
  interlude
  # If you wish, you can run the tests
  # Depending on your machine, they could take over half an hour to run
  make rakudo-test
  interlude
  make rakudo-spectest
  interlude
  make install
  interlude
  echo "export PATH=$(pwd)/install/bin/:$(pwd)/install/share/perl6/site/bin:\$PATH" >> ~/.bashrc
  source ~/.bashrc

Certes, j'ai lancé ce script sur une machine virtuelle, donc nécessairement moins puissante 
que la machine physique hôte. Néanmoins, cela donne une idée du temps nécessaire.

  make                   1h 40mn
  make rakudo-test          20mn
  make rakudo-spectest   3h 10mn
  make install           1h

Notons qu'il y a des erreurs, mais que je suis passé outre. Et je pense que c'est justifié, au moins
dans le cas de "spectest". En effet, on sait que Rakudo Star n'implémente pas complètement la spécification
de Perl 6, ce qui se traduit par des erreurs dans "spectest". C'est normal.

=head2 Utilisation

=head3 Identifiants

Il paraît qu'avec Perl 5, on pouvait utiliser des lettres accentuées dans les
identifiants de variable ou de fonction. Je n'ai jamais osé le faire avec Perl 5,
mais je ne m'en suis pas privé avec Perl 6. De plus, il est possible d'utiliser
le tiret à l'intérieur d'un identifiant à la place du souligné. Avec quelques 
limites, par exemple le tiret ne peut pas être suivi d'un chiffre, il faut que
ce soit une lettre. On ne peut pas utiliser C<$coef-1>, il faut utiliser C<$coef_1>,
car C<$coef-1> représente la valeur de C<$coef> diminuée de 1.

L'inconvénient, c'est que j'ai tendance à déclarer une variable C<$code-retour>
et à l'appeler ensuite C<$code_retour> (ou l'inverse). Je devrais utiliser
plus souvent l'auto-complétion d'Emacs (C<M-/>).

=head3 Indices négatifs

À un moment, dans un programme, il fallait que j'additionne ainsi
les éléments de deux tableaux (en syntaxe Perl 5)

  $t[0] = $a[0] + $b[4];
  $t[1] = $a[1] + $b[5];
  $t[2] = $a[2] + $b[0];
  $t[3] = $a[3] + $b[1];
  $t[4] = $a[4] + $b[2];
  $t[5] = $a[5] + $b[3];

Avec les index négatifs, on peut réécrire ces lignes ainsi en Perl 5 :

  $t[0] = $a[0] + $b[-2];
  $t[1] = $a[1] + $b[-1];
  $t[2] = $a[2] + $b[ 0];
  $t[3] = $a[3] + $b[ 1];
  $t[4] = $a[4] + $b[ 2];
  $t[5] = $a[5] + $b[ 3];

ou avec une boucle explicite

  for (0..5) {
    $t[$_] = $a[$_] + $b[$_ - 2];
  }

ou implicite

  @t = map { $a[$_] + $b[$_ - 2] } 0..5;

Mais en Perl 6, les indices négatifs sont interdits,
la syntaxe attendue est :

  @t[0] = @a[0] + @b[* - 2];
  @t[1] = @a[1] + @b[* - 1];
  @t[2] = @a[2] + @b[ 0];
  @t[3] = @a[3] + @b[ 1];
  @t[4] = @a[4] + @b[ 2];
  @t[5] = @a[5] + @b[ 3];

Donc impossible de faire cela en une seule boucle, il faut
en faire au moins deux. C'est nul, Perl 6...

... Puis j'ai pensé à APL. En APL, comment aurais-je fait ?
APL permet de faire cela sans même faire de boucle, en traitant
les vecteurs (nom indigène pour « tableaux ») dans leur totalité.
On commence par faire tourner le vecteur B sur lui-même pour
amener l'élément d'indice 4 (*) en première position.
Puis on l'additionne au vecteur A et on stocke le résultat
dans la variable T

(*) En fait, en APL, on a coutume de faire commencer les indices en 1.
Donc, c'est plutôt l'élément d'indice 5 que l'on place en position initiale.

  T ← A + ¯2 ⌽ B

Éh bien avec Perl 6, on peut faire l'équivalent :

  @t = @a «+» @b.rotate(-2);

APL, c'est génial, Perl 6 c'est génial !

=head3 Opérateurs Unicode

Un autre point que j'aime beaucoup dans APL, c'est que l'on peut
comparer des valeurs avec ≤ et ≥ au lieu de <= et >=. Et surtout,
on peut multiplier des nombres avec × au lieu de cette abominable étoile.
Éh bien on peut faire la même chose avec Perl 6 et utiliser ≤ ≥ et ×.
Lorsque j'ai fait un projet APL en 2014-2015, je m'étais écrit
une fonction C<apl-insert> en Emaces-Lisp pour insérer des caractères spéciaux dans
un source APL sous Emacs. Lorsque j'ai découvert la possibilité
d'utiliser ≤ ≥ et × en Perl 6, j'ai dupliqué ma fonction dans le
répertoire Perl 6 sans même purger les caractères APL qui ne
servent pas pour Perl 6 ni changer le nom de la fonction.

Remarque. Perl 5 connaissait déjà x pour multiplier une chaîne
par un nombre ou une liste par un nombre. Mais hélas, la
multiplication numérique utilisait toujours l'étoile.

À ce propos, la répétition de chaîne et la répétition de liste
sont deux opérateurs différents en Perl 6, respectivement « x »
et « xx ». Évitez d'utiliser l'un pour l'autre comme je l'ai fait !

=head3 Notation fonctionnelle

=for html
<img src='gof.png' width='45%' alt='Diagramme de Venn de la composition de deux fonctions' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>

Lorsque j'ai appris les relations et les fonctions en classe de 6e en mathématiques,
il y avait un point que je n'aimais pas et qui piégeait nombre de mes
camarades de classe, la notation pour la composition des fonctions.
Ainsi, « f suivie de g » se note « g rond f » et non pas « f rond g ».
La raison invoquée est qu'avec la notation fonctionnelle proposée par
Euler, on a :

     y = f(x)
     z = g(y)

donc

     z = g(f(x)) = gof (x)

J'ai beau être accoutumé à cette notation où les fonctions s'emboîtent
les unes dans les autres de façon que l'ordre chronologique se lit de droite
à gauche, je persiste à ne pas aimer. Et en plus, la quasi-totalité des
langages de programmation ont pris la suite du S<« traducteur> de S<formules »>
de Backus (FORTRAN) et reprennent allègrement cette monstruosité syntaxique.
Par exemple, vous prenez une valeur x, vous lui appliquez successivement
la fonction logarithme, la fonction cosinus, vous en prenez la valeur absolue
puis la racine carrée.
En dessinant un diagramme de Venn, cela donne :

=for html
<img src='hogof.png' width='45%' alt='Diagramme de Venn de la composition de quatre fonctions' />

I<Image personnelle. Les conditions de licence sont les mêmes que pour le texte.>

et en programmation, par exemple avec Perl 5 :

  $y = sqrt(abs(cos(log($x))))

Seul rayon de soleil dans cette grisaille, les calculatrices
HP mais aussi TI, qui permettent de coder dans l'ordre naturel :

  RCL 0
  LN
  COS
  ABS
  SQRT
  RTN

plus peut-être d'autres langages tels que Forth et Postscript que je n'ai jamais
appris, ou Smalltalk que j'ai à peine pratiqué.

Et maintenant, il y a aussi Perl 6 :

  $y = $x.log.cos.abs.sqrt;

=head3 Transformée schwartzienne

Si vous connaissez déjà la transformée schwartzienne, allez directement
L<au paragraphe suivant|"Transformation schwartzienne en Perl 6">.

=head4 Rappel de la Transformée schwartzienne en Perl 5

Supposons que je veuille trier une liste de chaînes de caractères en fonction
d'une date qui s'y trouve. La solution basique consiste à écrire :

  my @t = split /---\n/, <<'EOF';
  Georges Guynemer disparaît le 11 septembre 1917 aux environs de Poelcappelle.
  ---
  Le 21 avril 1918, Manfred von Richthofen est abattu à Vaux-sur-Somme.
  L'a-t-il été par le canadien Albert Roy Brown ou bien par les artilleurs de la 53e Batterie Australienne ?
  ---
  Première victoire aérienne à l'est : Petr Nicolaevitch Nesterov a volontairement percuté un Albatros autrichien le 8 septembre 1914.
  ---
  5 octobre 1914, première victoire en combat aérien par Frantz et Quenault sur le front ouest.
  ---
  Charles Nungesser, un temps surnommé « le Hussard de la Mors », est plus connu pour sa tentative de traversée
  de l'Atlantique le 8 mai 1927 et qui s'est terminée tragiquement que pour ses 45 victoires.
  ---
  La RAF a été créée le 1er avril 1918. Quel sens de l'humour !
  ---
  Sarajevo, 28 juin 1914 : un attentat qui a fait plus de 18 millions de morts et combien de blessés...
  ---
  11 novembre 1918, le cauchemar s'interrompt pour une vingtaine d'années.
  EOF

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;
  my $re = join '|', keys %mois;

  sub extr {
    my ($ch) = @_;
    if ($ch =~ /(\d{1,2})(?:er)?\s+($re)\s+(\d{4})/) {
      return $3 * 10000 + $mois{$2} * 100 + $1;
    }
    else {
      return 1e8;
    }
  }

  my @t1 = sort { extr($a) <=> extr($b) } @t;
  say join "\n", @t1;

En mettant un mouchard dans la fonction de comparaison, on constate qu'elle est appelée 15 fois,
donc la fonction C<extr> est appelée 30 fois, pour trier 8 paragraphes. L'idée est donc de 
remplacer 

  my @t1 = sort { extr($a) <=> extr($b) } @t;

par

  my @t0 = map {  [ $_, extr($_) ] } @t;
  my @t1 = sort { $a->[1] <=> $b->[1] } @t0;
  my @t2 = map { $_->[0] } @t1;

Ainsi, la fonction d'extraction est appelée 8 fois au lieu de 30 et son résultat est conservé.
Mais habituellement, on écrit de façon plus concise et plus synthétique :

  my @t2 = map { $_->[0] }
           sort { $a->[1] <=> $b->[1] }
           map {  [ $_, extr($_) ] } @t;

=head4 Transformation schwartzienne en Perl 6

Le problème avec cette expression concise,

  my @t2 = map { $_->[0] }
           sort { $a->[1] <=> $b->[1] }
           map {  [ $_, extr($_) ] } @t;

c'est qu'il faut la lire de bas en haut ou de droite à gauche, dans
le sens inverse de la lecture normale (pour nous, habitués de l'alphabet
latin). C'est comme la composition des fonctions avec la notation
héritée d'Euler.

Avec Perl 6, nous avons l'opérateur I<feed>, ou C<< ==> >>, qui permet
de faire comme les I<pipes> Unix, travailler de gauche à droite et
de haut en bas. Ainsi, le programme devient :

  use v6;

  my @t = split "---\n", q:to/EOF/;
  Georges Guynemer disparaît le 11 septembre 1917 aux environs de Poelcappelle.
  ---
  Le 21 avril 1918, Manfred von Richthofen est abattu à Vaux-sur-Somme.
  L'a-t-il été par le canadien Albert Roy Brown ou bien par les artilleurs de la 53e Batterie Australienne ?
  ---
  Première victoire aérienne à l'est : Petr Nicolaevitch Nesterov a volontairement percuté un Albatros autrichien le 8 septembre 1914.
  ---
  5 octobre 1914, première victoire en combat aérien par Frantz et Quenault sur le front ouest.
  ---
  Charles Nungesser, un temps surnommé « le Hussard de la Mors », est plus connu pour sa tentative de traversée
  de l'Atlantique le 8 mai 1927 et qui s'est terminée tragiquement que pour ses 45 victoires.
  ---
  La RAF a été créée le 1er avril 1918. Quel sens de l'humour !
  ---
  Sarajevo, 28 juin 1914 : un attentat qui a fait plus de 18 millions de morts et combien de blessés...
  ---
  11 novembre 1918, le cauchemar s'interrompt pour une vingtaine d'années.
  EOF

  my %mois = qw/janvier  1    février   2   mars      3
                avril    4    mai       5   juin      6
                juillet  7    août      8   septembre 9
                octobre 10    novembre 11   décembre 12/;

  my $re = rx/janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre/;

  sub extr(Str $ch) {
    if $ch ~~ /(\d+)'er'? \s+ ($re) \s+ (\d+)/ {
      return $2 × 10000 + %mois{$1} × 100 + $0;
    }
    else {
      return 1e8;
    }
  }

  @t ==> map { [ $_, extr($_) ] } \
     ==> sort { $^a[1] <=> $^b[1] } \
     ==> map { $_[0] } \
     ==> my @t1;

  say join "\n", @t1;

Juste un point qui me chagrine, la définition de l'expression régulière C<$re>.
En Perl 5, j'ai I<généré> cette expression régulière à partir du contenu
de C<%mois>. En Perl 6, j'ai été obligé de taper deux fois le nom des mois,
une fois pour le hachage, une autre fois pour l'expression régulière.
Les anglophones utilisent les rétro-acronymes I<DRY> (I<Don't Repeat Yourself>) 
et I<WET> (I<Write Everything Twice>) pour cela. Évidemment, il vaut mieux
travailler en I<DRY> qu'en I<WET>. Je ne sais pas comment faire pour ce point
particulier en Perl 6, mais un jour j'aurai la réponse.

=head3 Alignement vertical

Pour moi, l'alignement vertical dans le code est très important pour la compréhension
par un humain. Je ne parle pas simplement de l'indentation du premier caractère autre
que l'espace, je parle des éléments qui se répêtent d'une ligne à l'autre.
Par exemple, en Perl 5, je pourrais écrire :

  $longueur[$n] = $longueur[$n - 1] + $dx;
  $largeur [$n] = $largeur [$n - 1] + $dy;

En Perl 6, il est interdit d'écrire :

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur [$n] = @largeur [$n - 1] + $dy;

Car il ne doit pas y avoir d'espace entre le nom du tableau et le crochet ouvrant
qui donne l'indice. Il faudrait donc écrire ce code horrible :

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur[$n] = @largeur[$n - 1] + $dy;

Moi, je me suis résigné à écrire

  @longueur[$n] = @longueur[$n - 1] + $dx;
  @largeur[ $n] = @largeur[ $n - 1] + $dy;

Il existe une fonctionnalité intéressante que vous avez aperçue au paragraphe sur 
la transformation schwartzienne, le I<unspace>. S'il y a un backslash suivi par
un ou plusieurs caractères blancs (espace, saut de ligne, etc), alors l'interpréteur
Perl 6 considère qu'il n'y a pas de blanc. Ainsi, les deux lignes suivantes
sont équivalentes :

  @longueur[$n]
  @longueur\       [$n]

Cela aurait-il pu me servir dans mon exemple longueur-largeur ? Non, car l'ajout
du backslash pour masque le blanc dans la ligne "largeur" aurait créé un décalage d'un caractère supplémentaire.
Il aurait donc fallu insérer un blanc dans la ligne "longueur", ce qui en cascade
aurait nécessité d'insérer un autre backslash dans la ligne "longueur". Cela aurait
donné au final :

  @longueur\ [$n] = @longueur\ [$n - 1] + $dx;
  @largeur\  [$n] = @largeur\  [$n - 1] + $dy;


=head3 Expressions régulières

La syntaxe des regexps a été remaniée en profondeur. Reportez-vous systématiqement à la
doc lors de vos premières tentatives. Un exemple où je me suis fait avoir.
Pour tester qu'une chaîne de caractères ne contient que des chiffres 0, 1 et
5, ne pas écrire

  if $ch ~~ /^[015]+$/

mais

  if $ch ~~ /^[0|1|5]+$/

En fait, en lisant la documentation, la syntaxe est :

  if $ch ~~ /^<[015]>$/

=head3 Typage des valeurs et des variables

Une grande nouveauté de Perl 6, c'est le fait que l'on peut associer
un type à une variable et que l'interpréteur fera les
vérifications de type associées. Seulement voilà, les contrôles sont parfois
un peu trop stricts. Soit le bout de code suivant

  class Exemple {
    has Num $.grandeur is rw;
  }
  my Exemple $donnée .= new;
  $donnée.grandeur = 1;

Résultat :

  Type check failed in assignment to $!grandeur; expected Num but got Int (1)
    in block <unit> at exemple1.p6 line 5

Cet exemple de code plante, parce que l'interpréteur attend un
C<(Num)> et qu'on lui donne un C<(Int)>. Non, il n'y a pas de conversion
implicite des entiers vers les flottants. Qu'à cela ne tienne,
il suffit d'écrire

  $donnée.grandeur = 1.0;

et le tour est joué ! Éh bien non, ça plante encore, cette fois-ci
parce que paraît-il on veut mettre un C<(Rat)>, c'est-à-dire un rationnel, dans un C<(Num)> !
Je m'en suis tiré d'abord avec une conversion explicite :

  $donnée.grandeur = 1.Num;

ce qui n'est pas élégant. Puis je me suis rappelé de certains
modules Perl 5 qui devaient renvoyer un résultat « vrai » en contexte booléen avec
une valeur donnant zéro en contexte numérique. Il y a les modules qui écrivent

  return 0 but true;

Astucieux, mais cela ne m'aide pas. Et il y a les autres qui écrivent

  return "0e0";

Beaucoup plus intéressant. J'ai donc écrit

  $donnée.grandeur = 1e0;

et c'est S<passé !>

=head3 Undef et (nil)

Un autre point qu'il faudra que je règle, c'est le typage des paramètres 
dans les fonctions. Si la déclaration de la fonction attribue
un type à un paramètre et qu'on appelle cette fonction avec C<undef>,
le programme plante parce que l'on fournit une valeur de type C<(Nil)>
à un paramètre de type C<(Num)> (par exemple). Dans ce cas, je me résigne
pour l'instant à ne pas spécifier de type.

=head3 Références

Lorsque j'ai lu les livres qui m'ont servi à apprendre le langage,
j'ai constaté certaines omissions (Désolé Laurent). L'omission la
plus flagrante pour moi est concerne les références. Même si l'on écrit

  @t[2]

au lieu de

  $t[2]

pour accéder à un élément de tableau, la notation

  $t[2]

existe toujours et concerne la variable $t qui contient une référence à une liste.
L'équivalent en Perl 5 est

  $t->[2]

Je ne me suis pas privé d'utiliser des références dans mes programmes, mais j'aurais
bien aimé avoir l'aval des gourous sur la question.

Et pour convertir une référence de liste en liste ? Impossible d'écrire :

  my $ref = <A B C D E F>;
  my @liste = $ref;

car cela crée une liste avec un seul élément, la référence à une liste.
Il faut en fait écrire :

  my $ref = <A B C D E F>;
  my @liste = $ref[*];

=head3 Opérateurs spécifiques

Une autre lacune, mais qui est restée pour l'instant théorique pour mes besoins, c'est
la possibilité de créer ses propres opérateurs. Comment définit-on la
priorité de ces opérateurs par rapport aux opérateurs traditionnels ?

=head2 MongoDB

S<Avertissement :> hélas, je n'ai pas pris de notes lorsque j'ai installé le module MongoDB
pour Perl 6. J'expose ici mes souvenirs, qui ne sont pas fiables à S<100 %>.

D'autre part, ce que je raconte concerne l'installation que j'ai faite
le 17 mars. J'ai pu constater que l'auteur du module MongoDB pour Perl 6
s'était remis au travail fin avril. Les bugs que je signale ont peut-être
disparu (et d'autres sont apparus...). Je n'ai pas voulu prendre le risque
de réinstaller le module pendant que je réalisais mes programmes et que je
rédigeais mon exposé. Je referai une nouvelle installation au moment où je
migrerai vers xubuntu 18.04.

=head3 Installation du 17 mars 2018

Tout d'abord, un problème qui n'a rien à voir avec Perl 6. Sur ma machine,
la version de MongoDB est la version 2.6, alors que le site web donne
la documentation d'une version 3.x. Par exemple, le site propose une commande
C<findAndUpdate>, qui n'existe pas sur ma machine. D'accord, il y a la possibilité d'accéder
à la doc 2.6 (ou par anticipation à la doc 4.0), mais je me suis contenté
d'avoir une doc légèrement déphasée plutôt que de cliquer sur de nombreux liens
pour trouver la doc parfaitement adaptée.

Avec l'installateur intégré C<zef> de Rakudo Star, l'installation du 
L<module MongoDB|https://modules.perl6.org/t/DATABASE>
se fait simplement par :

  zef install MongoDB

Et ça plante. Normal, il faut lire le F<README>, qui indique qu'il y a des problèmes
dans les scripts de tests et qu'il faut donc ne pas bloquer sur les erreurs obtenues.
Donc, faire :

  zef install --/test MongoDB

Et le module est installé ! Maintenant, il reste à écrire quelques programmes.
J'ai commencé par copier-coller l'exemple fourni dans la documentation
du programme. Mais ça plante ! D'après ce que je comprends des messages d'erreur,
cela plante à cause d'un sous-programme qui attend un paramètre C<(Str)> et qui
reçoit un C<(Int)>. Pour votre gouverne, il s'agit de trois lignes :

     debug-message("command done {$command.find-key(0)}");
 
Je vais donc dans le fichier désigné par le message d'erreur
(un fichier avec un nom horrible tiré d'un SHA1 ou d'un MD5) et je corrige en
supprimant les trois lignes en cause. Les messages de débug que je ne sais pas
interpréter, je me sens autorisé à les supprimer. Je reteste,
cela ne change rien. Je pense que le module figure en deux exemplaires : le fichier
source que j'ai modifié et un fichier de I<bytecode> que je n'ai pas vu.
Le I<bytecode> n'ayant pas changé, le bug est toujours là.

Je clone donc le
L<dépôt Git Hub|https://github.com/MARTIMM/mongo-perl6-driver/>, 
je supprime les trois messages de débug et je réinstalle par :

  zef install --/test .

(où « C<.> » désigne le répertoire courant, c'est à dire le dépôt Git local plutôt
que le dépôt hébergé par Github). Et C<zef> refuse car, me dit-il, le module est à jour.
En cherchant dans l'aide en ligne de C<zef>, je trouve une solution :

  zef install --force --/test .

Est-ce la bonne solution ? Je ne sais pas, mais au moins, ça fonctionne.
Le programme proposé dans la documentation du module fonctionne, à condition
d'enlever le C<findAndUpdate> qui n'existe pas en version 2.6.

Quand j'essaie de faire mes propres accès à MongoDB, j'ai de nouveau un 
problème, une histoire de promesse non tenue. Après moult tentatives, j'en viens
à la conclusion que dans un C<find>, il est indispensable de coder le paramètre :

      projection => ( _id => 0, )

c'est-à-dire, prendre tous les attributs du document, sauf l'attribut C<_id>.
Pourquoi cette exclusion ? Je ne sais pas. Tout ce que je sais, c'est que si l'on
exclut C<_id> ça fonctionne presque toujours (*), si l'on inclut implicitement C<_id> ça
ne fonctionne jamais. Donc maintenant, je code cette exclusion dans tous mes C<find>.

(*) Presque toujours, car il m'arrive de faire des erreurs sur d'autres points.

Tiens, j'ai mentionné S<« moult> S<tentatives »>. Le problème, c'est qu'à force de
zigzaguer dans les méandres de la syntaxe, j'ai effectué plusieurs tentatives identiques.
Pour éviter cette perte de temps, j'ai décidé au bout d'un certain temps d'écrire un livre de recettes, où je
mémorise chaque variante testée des accès à la base de données, avec les messages d'erreur
obtenus.

Par exemple, bien noter que l'instruction C<find> dans un programme Perl 6 ne reconnaîtra
pas les options C<sort>, C<limit> et C<find>. Et ce n'est pas un problème de version 2.6
contre 3.x, ces trois options sont mentionnées dans le livre O'Reilly de 2013 (page 68 si vous
voulez vérifier).

=head3 Installation du xx mai ou juin 2018

À faire quand j'aurai migré ma machine vers une distribution récente.

=head2 Bailador

Au début, je n'avais pas l'intention de faire du web dynamique. Puis j'ai trouvé que
les fichiers HTML, avec les liens hypertextes qui conviennent, c'est plus facile à 
lire que le résultat d'une requête écrite dans un interpréteur de JavaScript.

Donc, alors que j'ai installé Bailador. Que S<dire ?> J'ai installé le module, j'ai 
écrit un programme basé sur Bailador, et ça tourne. Je n'ai rien de croustillant 
à raconter.

Il faut dire que mon utilisation de Bailador est aussi rustique que l'utilisation 
de Dancer2 que j'ai présentée l'an dernier. Plus rustique même, puisque je n'utilise
pas de formulaires HTML. Si vous vous attendez à avoir autant
L<de modules pour Bailador|https://modules.perl6.org/t/WEB>
que ce dont vous disposez
L<pour Dancer2|https://metacpan.org/search?q=Dancer2>,
il va falloir attendre un peu (et, pourquoi pas, contribuer à l'effort).

=head1 Retour d'expérience sur l'As des As

Un point qui m'a surpris et auquel j'aurais pu penser, c'est la réaction
des pilotes en page 223 en mode combat.  Le but était de permettre
à un avion déjà bien amoché de fuir pour survivre et pour n'accorder
qu'un demi-point de victoire, au lieu de continuer à combattre avec
un net désavantage et d'accorder un point de victoire entier à l'ennemi.

Ce qui se passe en réalité, c'est que le choix de la fuite donne en moyenne
un résultat S<négatif :> -0.5 PV si l'adversaire préfère continuer le combat,
0 PV si l'adversaire souhaite lui aussi fuir. En revanche, la poursuite
du combat donne autant de chances de gagner le combat que de le perdre.
Donc en moyenne, un résultat nul, meilleur que la moyenne des résultats
de la fuite. C'est ainsi que les pilotes sont amenés à choisir la poursuite
du combat.

Ce qu'il faudrait faire, c'est moduler la note des résultats antérieurs
en comparant le potentiel restant de la situation actuelle et celui de ces
coups antérieurs. Si un pilote est en page 223 avec tout juste 2 points de
vie sur les 12 initiaux, on privilégiera les coups antérieurs avec 1, 2 ou
3 points de vie, tout en minimisant l'importance des coups antérieurs avec
8 points de vie ou plus. De la sorte, peut-être que les pilotes préféreront
fuir.

À compléter.

=head1 Conclusion

J'aime beaucoup Perl 6. J'avais quelques projets pour lesquels
j'envisageais d'utiliser APL, je pense que ces projets vont utiliser Perl 6
à la place. J'ai encore des lacunes à combler pour une bonne utilisation
de Perl 6, mais c'est juste une question de temps.

Quant au choix de l'As des As pour un projet dans le genre Google Alpha Go Zero,
il faut avoir à l'esprit que c'est un jeu beaucoup plus simple que le go
ou les échecs. Plus complexe que le tic-tac-toe certes, mais largement plus simple
de plusieurs ordres de grandeur que les deux jeux classiques. C'est pour cela
que j'ai pu créer un S<« Alpha> As des As S<Zéro »> sur un datacenter constitué
d'un seul PC de puissance moyenne.

=head1 LICENCE

Texte diffusé sous la licence CC-BY-NC-ND : Creative Commons avec clause de paternité, excluant l'utilisation commerciale et excluant la modification. 

Certaines illustrations sont diffusées avec une licence différente. Celle-ci est mentionnée à la suite de l'illustration.
