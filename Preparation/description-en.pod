# -*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf-8

=head1 INTRODUCTION

The programs for playing I<Ace of Aces> rely on a transition table
listing the transitions (start page, maneuver) → end page, stored in
a JSON file. We can type this JSON file by copying the 222-page
booklet, with 25 maneuvers per page for I<Handy Rotary>, that is, 5550
entries. This is boring and error-prone. And you have to do this for
at least two booklets. Even with I<Wingleader> and 13 maneuvers per
page, that amounts to 2886 entries for each booklet.

Fortunately, the different pages represent the location and heading of a 
plane on a 37-hexagon grid, with 6 possible headings. By using this
underlying geometry, we can just copy a significant subset of transitions
(start page, maneuver) → end page and generate the other by geometrical
computation and by inference.

Additionally, all the games of the series use the same 37-hexagon grid with
the same numbering. So, you have to build an electronic version of the
37-hexagon grid only once, and then you can initialize any booklet by 
specifying the 13 to 26 maneuvers (plus the fire table, which is harder to
compute).

So I built the electronic version of the hex-grid using the FW190 booklet
from I<Wingleader>, then I checked it by generating the booklets for
the Sopwith Camel and the Fokker DR1 from I<Handy Rotary> and for the 
P-51 and the FW190 from I<Wingleader>. I also generated booklets for
a new game involving a sparrohawk and a hobbyist's drone.

=head2 Warning

When I wrote the programs, I used French names for the programs, for
the variables, for the functions etc. Sorry about that, if you want to
read my programs, you will need to learn French in addition to Raku.

=head1 SPARROWHAWK vs. HOBBYIST DRONE

For copyright reasons, I do not want to publish on Github the JSON files
for the Sopwith Camel, the Fokker DR1, the P-51 Mustang and the FW190.
The patent has expired, but not the copyright on I<Handy Rotary> and
I<Wingleader>. So I created a game "sparrowhawk vs. hobbyist drone",
after recent incident reports describing brutal encounters between
birds of prey and drones. In the game, the drone tries to film the bird, while the
brid tries to destroy the drone.

While most animals and most vehicules on Earth have a front / back
orientation, the drone, a quadcopter, has no real orientation for its
movements, a bit like jellyfish and sea anemones. It can easily move
backward or sideways as easily as forward. It still has a front / back
orientation, because I consider that the camera is rigidly fixed on
the drone frame, so the front of the drone is the view field of the
camera.

I do not pretend that the game is interesting, especially since I do not
provide the pictures which are an important element for human players.
I do not pretend either it is balanced. But the game has been created by me,
so I am entitled to publish it on Github or elsewhere under any free license I choose.

In the following, I describe the preparation as if I had used the "Drone" booklet
since the beginning.

=head1 STEPS

=head2 Typing

Using your preferred text editor, write a F<Drone-init.json> file. This file
describes the maneuvers the drone can execute and the pages where it can 
"shoot" at the sparrowhawk (actually shooting film). The file does not contain
any transition (start page, maneuver) → endpage.

=head2 Initialization

The F<init.p6> program initializes or resets a F<aoa_prep> MongoDB database.

Then it copies the contents of F<Drone-init.json> in a C<Manoeuvres> 
collection (French for "maneuvers"). And it initializes another collection,
C<Pages>, with only two pages: page 223, which has a special status and
page 187, an ordinary page from which we will bootstrap the geometrical description.

The choice of page 187 is partly an abritrary one. This is the page
where both planes are in the same hex with the same heading. But I could have
bootstraped the process with any other ordinary page.

=head2 Incremental Update

"Update" translates to I<mise à jour> in French, so the update program
is named F<maj.p6>. This is a command-line program, which receives as
input parameters a page number, plus the transitions maneuver → end
page. For example, the first time it will run, the command line will
be:

  perl6 maj.p6 --page=187 -a=205 -b=187 -c=198 -d=3 -e=15 -f=16 -g=2 -h=17 -i=1

That means that when the start page is page 187, the end page for maneuver C<"A">
is page 205, the end page for maneuver C<"B"> is page 187 and so on.
If the command line parameters include an unknown page, the program
creates it in the C<Pages> collection, initializing its position in the
hexgrid and the heading of the plane (or drone, or bird, or...).

In addition, the program takes the new pages and applies all the maneuvers
to them. If the result is a known page, the transition maneuver → end page
is stored in C<Pages> collection. If the end page is not known yet, no update
takes place.

The program also applies I<backward> the maneuvers to new pages to check other
transitions (start page, maneuver) → end page, where the end page is the page
currently processed and the start page is hopefully a page already known.

This backward processing did not exist in the first version, in March 2018, I added it in
June 2018. Instead, I had a paramter triggering a full computation, for all known
pages, old and new alike. Very time-consuming.

=head3 Example

Let us consider a flying machine with fewer maneuvers than the drone. The only
three maneuvers are:

=over 4

=item * Maneuver A, a port sideslip to the hex at 10 o'clock without heading change

=item * Maneuver B, move forward

=item * Maneuver C, a starboard sideslip to the hex at 2 o'clock without heading change

=back

  .                       --------
  .                      /        \
  .              --------    B     --------
  .             /        \        /        \
  .            (    A     --------     C    )
  .             \        /        \        /
  .              --------   start  -------- 
  .                      \        /
  .                       -------- 

After F<init.p6>, the only known page is 187 (except for page 223, a special one).
So the first run of F<maj.p6> is:

  perl6 maj.p6 -page=187 -a=15 -b=16 -c=17

The program updates the transitions with:

  (187, A) → 15
  (187, B) → 16
  (187, C) → 17

And the map is filled with:

  .                       --------
  .                      /        \
  .              --------    16    --------
  .             /        \        /        \
  .            (    15    --------    17    )
  .             \        /        \        /
  .              --------   187    -------- 
  .                      \        /
  .                       --------

The program processes the newly created pages, 15, 16 and 17 and applies the
maneuvers A, B and C to them. With three hexes and three maneuvers, it makes
nine attempts, two of which succeed. With that, the program adds the transitions:

  ( 15, C) → 16
  ( 17, A) → 16

The second call to F<maj.p6> applies to page 16:

  perl6 maj.p6 -page=16  -a=46 -b=91 -c=107

The program updates the transitions with:

  ( 16, A) →  46
  ( 16, B) →  91
  ( 16, C) → 107

And the map expands with:

  .                       -------- 
  .                      /        \
  .              --------    91    --------
  .             /        \        /        \
  .            (    46    --------   107    )
  .             \        /        \        /
  .              --------    16    --------
  .             /        \        /        \
  .            (    15    --------    17    )
  .             \        /        \        /
  .              --------   187    -------- 
  .                      \        /
  .                       --------

Like the first time, the program applies the maneuvers to the newly
created pages, with 9 attempts, 7 of which fail and 2 of which succeed.
So the following transitions are added:

  ( 46, C) → 91
  (107, A) → 91

In addition, the program applies the maneuvers backward to the newly
created pages. The result gives some already known transitions:

  (x, A) →  46 with x =  16
  (x, A) →  91 with x = 107
  (x, B) →  91 with x =  16
  (x, C) →  91 with x =  46
  (x, C) → 107 with x =  16

Some attempts fail:

  (x, C) →  46
  (x, A) → 107

And some attempts give new results

  (x, B) →  46 with x = 15
  (x, B) → 107 with x = 17

So the following records are added:

  ( 15, B) →  46
  ( 17, B) → 107

=head3 Iterations

The program F<maj.p6> is called enough times to get all transitions
for all pages and all maneuvers. Since the drone has 9 maneuvers, one
of which is immobility, only 8 maneuvers may give new results. So we
need at least 222/8 calls, that is 28 calls. Since there is some
overlay, I ended up with 48 calls. There was perhaps a faster
solutionn but I doubt there could be a much faster solution.

=head2 Display

"Display" translates as I<Affichage>, so the program name is F<aff.p6>.
This program generates an HTML table listing all the known pages
and transitions. This helps me choosing the next page I will use
when running F<maj.p6>, because it is more efficient to use a page
with 2 known transitions and 7 unknown transitions than a page
with 7 known transitions and 2 unknown transitions.

=head2 Booklet Generation

"Booklet" translates as I<livret>, so the program is named F<livret.p6>.

The iterative process ends when every page has been mentioned at least once
in the parameters of F<maj.p6>, that is, when the hexgrid is entirely known.

At this time, we can generate a booklet for any flying machine or any flying
creature. The program F<livret.p6> reads a small size F<Sparrowhawk-init.json>
file and generates a full size F<Sparrowhawk.json> file, plus a more user-friendly
F<Sparrowhawk.html>, both of which contain the full list of transitions
(start page, maneuver) → end page.


=head1 License

This text is published under the CC-BY-NC-ND license: Attribution-NonCommercial-NoDerivs 2.0 Generic.
