# -*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf-8

=head1 INTRODUCTION

Les programmes de jeu pour l'As des As se basent sur une table
de transition (page de départ, manœuvre) → page d'arrivée,
stockée dans un fichier JSON. I<Handy Rotary> comporte 25 manœuvres par page.
Recopier un livret avec 222 pages et 25 manœuvres dans un fichier JSON, soit 5550 entrées,
est fastidieux, donc sujet à erreur. Et il faut le faire pour au moins
deux livrets. Même dans le cas de I<Wingleader>, qui a seulement 13 manœuvres
par page, cela ferait 2886 entrées à taper pour chaque livret.

Heureusement, les différentes pages correspondent au positionnement d'un
avion sur une grille de 37 hexagones avec 6 orientations possibles.
En se basant sur cette géométrie sous-jacente, il est possible 
de saisir un sous-ensemble représentatif 
de transitions (page de départ, manœuvre) → page d'arrivée
et d'obtenir toutes les autres par calcul et par déduction.

De plus, tous les jeux de la série utilisent la même grille de 37 hexagones
avec la même numérotation. Donc, il suffit de déterminer une bonne
fois pour toutes les numéros de page des hexagones et tous les livrets
peuvent être alors générés en décrivant les 13 à 26 manœuvres disponibles
(plus la table des tirs, qu'il est difficile d'automatiser).

J'ai ainsi reconstitué la grille hexagonale en me basant sur le
livret FW190 de I<Wingleader>, puis j'ai généré le fichier JSON
pour le Sopwith Camel et le Fokker DR1 de I<Handy Rotary>,
pour le P-51 et le FW190 de I<Wingleader> (à titre de vérification)
et pour un jeu similaire mettant en scène un épervier aux prises
avec un drone de loisir.

=head1 ÉPERVIER CONTRE DRONE DE LOISIR

Pour des raisons de copyright, je ne peux pas diffuser sur Github
les fichiers JSON du Camel, du DR1, du Mustang ou du FW. Le brevet
sur le mécanisme du jeu a expiré, mais le copyright sur I<Handy Rotary>
et sur I<Wingleader> est toujours actif. J'ai donc créé un jeu
S<« épervier> contre drone de S<loisir »> en me basant sur des
anecdotes récentes racontant les rencontres brutales entre des oiseaux
de proie et des drones de loisir. Le but du drone est de filmer l'épervier,
tandis que le but de l'épervier est de détruire le drone.

Alors que la plupart des animaux et des véhicules sur terre ont une
orientation avant / arrière, le drone, de type quadrocopter, n'a pas
d'orientation précise pour ses déplacements, semblable aux méduses et
aux anémones de mer. Il peut aussi facilement aller en avant qu'en
arrière ou de côté. Il a quand même un avant et un arrière, car je
suppose que la caméra est fixe et immobile par rapport au chassis du
drone. Ainsi, l'avant du drone correspond au champ visuel de sa
caméra.

Je ne prétend pas que ce jeu soit très intéressant, surtout
qu'il n'y a pas les dessins qui sont l'un des points forts
de l'I<As des As>. Je ne prétend pas non plus qu'il soit
équilibré. Mais ce jeu est ma création, donc
je peux le diffuser sur Github à ma guise, avec la licence libre
qui me plaît.

Donc dans la suite, je présente la préparation comme si je m'étais basé
sur un livret S<« drone »> existant au lieu du livret FW190.

=head1 ÉTAPES

=head2 Saisie

Sous éditeur de texte, écrire un fichier F<Drone-init.json>.
Ce fichier contient la description des manœuvres du drone, ainsi que les
pages où le drone peut S<« tirer »> sur l'épervier (c'est-à-dire le filmer). Le fichier ne contient aucune
transition (page de départ, manœuvre) → page d'arrivée.

=head2 Initialisation

Le programme F<init.p6> commence par vider le contenu de la base F<aoa_prep> dans MongoDB.

Ensuite, il recopie le fichier F<Drone-init.json> dans
une collection C<Manoeuvres> de la base MongoDB. Il initialise une autre
collection C<Pages> avec deux S<pages :> la page 223, puisqu'elle a un statut
spécial, et la page 187 qui est une page normale.

Le choix de la page 187 est en partie arbitraire. C'est la page qui correspond
à la situation où les deux joueurs sont l'un au-dessus de l'autre dans le
même hexagone et avec le même cap. Mais j'aurais très bien pu choisir
une autre page initiale.

=head2 Mise à jour incrémentale

Le programme F<maj.p6> est un programme en ligne de commande
qui reçoit comme paramètres un numéro de page de départ
et la liste des transitions manœuvre → page d'arrivée
pour cette page. Par exemple la première fois qu'on l'exécutera,
ce sera forcément avec la page 187, donc la ligne de commande S<sera :>

  perl6 maj.p6 --page=187 -a=205 -b=187 -c=198 -d=3 -e=15 -f=16 -g=2 -h=17 -i=1

Le programme met à jour les 
transitions (page de départ, manœuvre) → page d'arrivée.
Si la ligne de commande mentionne des pages d'arrivée que l'on n'avait pas
encore rencontrées jusqu'à présent, le programme détermine où se situent
ces pages dans la grille hexagonale et quelle est l'orientation de
l'avion (ou du drone, ou de l'oiseau, etc).

En outre, le programme applique chaque manœuvre à chacune des
nouvelles pages. Si le résultat est une page déjà identifiée, le programme
renseigne cette transition (page de départ, manœuvre) → page d'arrivée
dans la base de données. Si le résultat n'est pas connu, le programme laisse
tomber cette transition pour l'instant.

Également, le programme applique les manœuvres
S<« à> S<rebrousse-poil »> pour déterminer les
transitions (page de départ, manœuvre) → page d'arrivée
dans laquelle la page d'arrivée est la nouvelle page et la page
de départ est une page déjà ajoutée précédemment.

Cette recherche S<« à> S<rebrousse-poil »> n'existait pas dans
la version de mars 2018, je l'ai ajoutée en juin 2018. À la place,
j'avais un paramètre S<« recalcul> S<complet »> qui passait en
revue I<toutes> les pages, les anciennes comme les nouvelles
et qui déterminait pour chaque manœuvre la page d'arrivée.
Très chronophage.

=head3 Exemple

Prenons un engin avec très peu de manœuvres disponibles.
La manœuvre A, qui permet un déplacement en crabe vers l'hexagone
voisin à 10 heures, la manœuvre B qui fait avancer dans l'hexagone
juste devant la position initiale et la manœuvre C qui permet un
déplacement en crabe vers l'hexagone voisin à 2 heures.

Désolé pour les hexagones en I<ASCII art>, un jour je referai les
schémas en METAPOST. Peut-être.


  .                       --------
  .                      /        \
  .              --------    B     --------
  .             /        \        /        \
  .            (    A     --------     C    )
  .             \        /        \        /
  .              --------  départ  -------- 
  .                      \        /
  .                       -------- 

Suite à F<init.p6>, la seule page connue est la page 187 (outre la
page 223 dont le statut est spécial). Le premier appel de F<maj.p6>
est donc :

  perl6 maj.p6 -page=187 -a=15 -b=16 -c=17

Le programme met à jour les enchaînements avec :

  (187, A) → 15
  (187, B) → 16
  (187, C) → 17

Et la carte est complétée avec :

  .                       --------
  .                      /        \
  .              --------    16    --------
  .             /        \        /        \
  .            (    15    --------    17    )
  .             \        /        \        /
  .              --------   187    -------- 
  .                      \        /
  .                       --------

En examinant les pages nouvellement créées 15, 16 et 17 et en leur appliquant
les manœuvres A, B et C, le programme constate que sur les 9 tentatives, deux
réussissent. Par conséquent, il ajoute les enchaînements 

  ( 15, C) → 16
  ( 17, A) → 16

Le deuxième appel à F<maj.p6> s'applique à la page 16 :

  perl6 maj.p6 -page=16  -a=46 -b=91 -c=107

Le programme met à jour les enchaînements avec :

  ( 16, A) →  46
  ( 16, B) →  91
  ( 16, C) → 107

Et la carte est complétée avec :

  .                       -------- 
  .                      /        \
  .              --------    91    --------
  .             /        \        /        \
  .            (    46    --------   107    )
  .             \        /        \        /
  .              --------    16    --------
  .             /        \        /        \
  .            (    15    --------    17    )
  .             \        /        \        /
  .              --------   187    -------- 
  .                      \        /
  .                       --------

En examinant les pages nouvellement créées 46, 91 et 107 et en leur appliquant
les manœuvres A, B et C, le programme
ajoute les enchaînements 

  ( 46, C) → 91
  (107, A) → 91

Le programme applique également les manœuvres A, B et C à rebrousse-poil
sur les pages 46, 91 et 107. On retrouve certains enchaînements déjà S<créés :>

  (x, A) →  46 avec x =  16
  (x, A) →  91 avec x = 107
  (x, B) →  91 avec x =  16
  (x, C) →  91 avec x =  46
  (x, C) → 107 avec x =  16

il y a quelques S<échecs :>

  (x, C) →  46
  (x, A) → 107

mais également quelques S<réussites :>

  (x, B) →  46 avec x = 15
  (x, B) → 107 avec x = 17

ce qui permet d'ajouter les S<enregistrements :>

  ( 15, B) →  46
  ( 17, B) → 107

=head3 Itérations

Le programme F<maj.p6> est appelé autant de fois qu'il le faut pour
que toutes les transitions soient connues pour toutes les pages
et toutes les manœuvres. Tous ces appels sont accumulés dans le
script shell F<maj1>, de sorte que l'on peut refaire la totalité
des itérations en un seul appel de F<maj1>.

Avec 9 manœuvres, dont une (C<B>) qui consiste à faire du sur-place,
il faut au moins 28 itérations pour définir toutes les pages.
Compte tenu des recouvrements inévitables, il a fallu 48 appels
de F<maj.p6> pour définir toutes les pages. Il y avait peut-être
plus rapide, mais pas tellement plus rapide.

=head2 Affichage

Le programme F<aff.p6> affiche le contenu de la base de données
sous la forme d'un tableau HTML. Cela me sert lors du processus
itératif à choisir quelle page je vais utiliser lors du prochain appel
de F<maj.p6> (ou des deux prochains appels, ou des trois, ou...). Inutile de saisir une
page pour laquelle on connaît déjà les deux tiers des enchaînements
s'il en existe pour lesquelles on n'en connaît qu'un ou deux.

=head2 Génération du livret

Le processus itératif se termine lorsque toutes les pages
ont été citées au moins une fois lors des appels à F<maj.p6>
et donc quand on connaît la position de toutes les pages.

On peut alors générer un livret pour n'importe quel objet volant
ou n'importe quelle créature volante. Le programme F<livret.p6>
lit en entrée un fichier F<Epervier-init.json> de taille réduite
et produit un fichier complet F<Epervier.json> et un fichier
F<Epervier.html> qui contiennent la totalité des
transitions (page de départ, manœuvre) → page d'arrivée.

=head1 FONCTIONNEMENT INTERNE

=head2 Repérage des hexagones

Au début, j'ai envisagé d'utiliser un système de coordonnées cartésiennes avec
un repère orthonormé.

  .                       -------- 
  .                      /        \               Numéro     X         Y
  .              --------    16    --------            2     0        -1
  .             /        \        /        \           3    -0.866    -0.5
  .            (    15    --------    17    )          1     0.866    -0.5
  .             \        /        \        /         187     0         0
  .              --------   187    --------           15    -0.866     0.5
  .             /        \        /        \          17     0.866     0.5
  .            (     3    --------     1    )         16     0         1
  .             \        /        \        /
  .              --------    2     -------- 
  .                      \        /
  .                       --------

Puis un repère orthogonal sans être normé

  .                       -------- 
  .                      /        \               Numéro     X         Y
  .              --------    16    --------            2     0        -1
  .             /        \        /        \           3    -1        -0.5
  .            (    15    --------    17    )          1     1        -0.5
  .             \        /        \        /         187     0         0
  .              --------   187    --------           15    -1         0.5
  .             /        \        /        \          17     1         0.5
  .            (     3    --------     1    )         16     0         1
  .             \        /        \        /
  .              --------    2     -------- 
  .                      \        /
  .                       --------

Ou un repère normé sans être orthogonal (l'axe des X est incliné, tandis que
l'axe des Y est, comme à l'accoutumée, vertical). Ne rigolez pas, certains
jeux d'Avalon Hill utilisent un tel système de coordonnées.

  .                       -------- 
  .                      /        \               Numéro     X         Y
  .              --------    16    --------            2     0        -1
  .             /        \        /        \           1     1        -1
  .            (    15    --------    17    )          3    -1         0
  .             \        /        \        /         187     0         0
  .              --------   187    --------           17     1         0
  .             /        \        /        \          15    -1         1
  .            (     3    --------     1    )         16     0         1
  .             \        /        \        /
  .              --------    2     -------- 
  .                      \        /
  .                       --------

Les coordonnées polaires semblent offrir plus de promesses. D'ailleurs, c'était utilisé
par les pilotes de la Seconde Guerre Mondiale avec le système du cadran d'horloge.

  .                       -------- 
  .                      /        \               Numéro     R      angle
  .              --------    16    --------          187     0      indéfini
  .             /        \        /        \          16     1        12h
  .            (    15    --------    17    )         17     1         2h
  .             \        /        \        /           1     1         4h
  .              --------   187    --------            2     1         6h
  .             /        \        /        \           3     1         8h
  .            (     3    --------     1    )         15     1        10h
  .             \        /        \        /
  .              --------    2     -------- 
  .                      \        /
  .                       --------

Pour simplifier, j'ai utilisé des incréments de 60 degrés orientés dans le sens des aiguilles
d'une montre avec une plage de 0 à 5. Cela correspond à la moitié de l'angle du cadran d'horloge,
sachant que 12h est converti en B<0> au lieu de B<6>.

Si l'angle polaire ou le gisement ne correspond pas à un multiple de 60 degrés, alors
on utilise le chemin le plus court, en utilisant deux directions de C<0> à C<5>.
Voici par exemple les chemins depuis l'hexagone S<187 :>


  .                       -------- 
  .                      /        \               Numéro     chemin
  .              --------    91    --------          187     (rien)
  .             /        \        /        \          16     0
  .     --------   118    --------   107    )         17     1
  .    /        \        /        \        /           1     2
  .   (    54    --------    16    --------            2     3
  .    \        /        \        /        \           3     4
  .     --------    15    --------    17    )         15     5
  .    /        \        /        \        /          54     55
  .   (    76    --------   187    --------           76     45
  .    \        /        \        /        \          91     00
  .     --------     3    --------     1    )        107     01
  .             \        /        \        /         118     05
  .              --------    2     --------          
  .                      \        /
  .                       --------

Dans tout cela, je n'ai pas tenu compte de la différence de cap entre
les deux avions. On utilise la même notation de C<0> à C<5>.
Ainsi, si les deux avions sont parallèles comme dans la page 1 de l'exemple,
leur différence de cap sera C<0>. Mais dans la page 8, la différence
de cap de l'Allemand relativement à l'Anglais est C<5>.

=head2 Représentation interne

Les programmes utilisent deux représentations pour un hexagone, la
représentation en chaîne de caractères et la représentation numérique.
La représentation en chaîne de caractères énumère les directions de
déplacement depuis la position de l'avion anglais pour arriver à la
position de l'avion allemand, ajoute un point-virgule et termine
avec l'écart de caps entre les deux avions. Ainsi, la page 1
est représentée S<par :>

  2;0

Car l'hexagone de l'avion allemand est situé dans la direction C<2> par rapport
à celui de l'avion anglais et que les deux avions ont le même cap. La page 8
a pour S<code :>

  2;5

car il s'agit du même hexagone, mais l'avion allemand a pivoté de 60 degrés
vers babord. Cette chaîne de caractères est stockée dans l'attribut C<$.chemin>.

La représentation numérique comporte un tableau C<@.avance> et un scalaire C<$.virage>
Le scalaire C<$.virage> reprend l'écart de caps entre les deux avions. Le tableau C<@.avance>
compte le nombre de pas dans les directions C<0> à C<5>. S<Exemples :>

  page         1     8     42     159
  $.chemin     2;0   2;5   00;1   112;1
  @.avance[0]  0     0     2      0
  @.avance[1]  0     0     0      2
  @.avance[2]  1     1     0      1
  @.avance[3]  0     0     0      0
  @.avance[4]  0     0     0      0
  @.avance[5]  0     0     0      0
  $.virage     0     5     1      1

=head3 Cas particuliers

Il existe 6 pages représentant les deux avions dans le même hexagone, l'un au-dessus 
de l'autre (la seule intervention de l'altitude dans le jeu d'introduction). Dans ce 
cas, toutes les valeurs de C<@.avance> sont à zéro et le contenu de C<$.chemin> commence
par un point-virgule. Ainsi, la page 187 représente les avions dans le même hexagone
avec le même cap, donc C<$.chemin> contient S<« C<;0> »>. Page 188, les deux avions sont
aussi dans le même hexagone, mais dans des directions opposées. C<$.chemin> contient
alors S<« C<;3> »>.

=head3 Normalisation

Comme cela a déjà été signalé, le chemin utilisé doit être le chemin le plus court
possible. Cela dit, en reprenant l'exemple de la page 150, le chemin de 187 vers 150 peut être
C<112;1>, mais aussi C<121;1> ou C<211;1>. Comme la valeur sert de clé de recherche dans les
programmes, il faut que l'on se mette d'accord sur une valeur normalisée. On prend le
chemin dans lequel les pas élémentaires sont dans l'ordre croissant. C'est-à-dire
C<112;1> dans le cas de la page 150.

Cette problématique ne concerne pas la représentation numérique.

Une autre problématique concerne les deux représentations. Il se peut que l'on obtienne
un chemin plus long que le chemin minimal, par exemple à la suite d'un calcul. 
Ainsi, le chemin C<13;0> est équivalent au chemin C<2;0>. Il faut donc ajuster le
chemin courant jusqu'à obtenir la version équivalente la plus courte. Pour ce faire,
il suffit d'appliquer deux mécanismes.

Si le chemin contient des pas avec un écart de 180°, par exemple C<0> avec C<3>, ou C<1> avec C<4>,
alors ces pas élémentaires s'éliminent deux à deux. Par exemple, C<1244;5> devient C<24;5>, le C<1>
ayant éliminé l'un des deux C<4>.

L'autre cas est celui où le chemin contient des pas écartés de 120°. Alors on remplace ces pas
par leur bissectrice. Voir l'exemple déjà cité, où C<13;0> devient C<2;0>, ou la suite de l'exemple
précédent où C<24;5> devient C<3;5>. Ou bien, plus complexe,
C<1123;3> devient C<122;3> en remplaçant C<13> par C<2>. Ou encore, C<135;1> devient C<25;1>, auquel on applique de nouveau la première
règle de normalisation, ce qui donne un chemin vide C<;1>. Remarquez que si l'on avait normalisé en
associant le C<3> et le C<5> pour les remplacer par C<4>, cela aurait donné un chemin C<14;1> qui, lui aussi, aurait donné
dans un deuxième temps le chemin vide C<;1>.


=head1 LICENCE

Texte diffusé sous la licence CC-BY-NC-ND : Creative Commons avec clause de paternité, excluant l'utilisation commerciale et excluant la modification. 
